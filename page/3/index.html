<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tate-zwt.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="「 少点虚的，多点实践 」">
<meta property="og:type" content="website">
<meta property="og:title" content="Tate Blog">
<meta property="og:url" content="https://tate-zwt.github.io/page/3/index.html">
<meta property="og:site_name" content="Tate Blog">
<meta property="og:description" content="「 少点虚的，多点实践 」">
<meta property="og:locale">
<meta property="article:author" content="爱吃番茄炒蛋">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tate-zwt.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Tate Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tate Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">iOS Developer</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2018/04/04/Restful-API%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/04/Restful-API%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Restful API学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-04 00:02:31" itemprop="dateCreated datePublished" datetime="2018-04-04T00:02:31+08:00">2018-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Restful是什么"><a href="#Restful是什么" class="headerlink" title="Restful是什么"></a>Restful是什么</h4><ul>
<li> 本质：一种软件架构风格</li>
<li> 核心：面向资源</li>
<li> 资源：网络上的一个实体，网络上的一个具体信息</li>
<li> 解决的问题：1、降低开发的复杂性；2、提高系统的可伸缩性</li>
</ul>
<p>也可以总结为一句话：Restful是所有Web应用都应该遵守的架构设计指导原则。 </p>
<h4 id="Restful中HTTP协议介绍"><a href="#Restful中HTTP协议介绍" class="headerlink" title="Restful中HTTP协议介绍"></a>Restful中HTTP协议介绍</h4><h5 id="http协议-url"><a href="#http协议-url" class="headerlink" title="http协议-url"></a>http协议-url</h5><blockquote>
<p>http是一个属于应用层的协议,特点是简捷、快速。</p>
</blockquote>
<p><strong>schema://host[:port]/path[?query-string][#anchor]</strong></p>
<ul>
<li>==scheme==   指定低层使用的的协议(例如：http,https,ftp)</li>
<li>==host==  服务器的IP地址或域名</li>
<li>==port==  服务器端口,默认为80</li>
<li>==path==  访问资源的路径</li>
<li>==query-string== 发送给http服务器的数据</li>
<li>==anchor== 锚</li>
</ul>
<hr>
<h5 id="http协议-请求"><a href="#http协议-请求" class="headerlink" title="http协议-请求"></a>http协议-请求</h5><blockquote>
<p>组成格式：请求行、消息报头、请求报文</p>
</blockquote>
<p><strong>请求行</strong></p>
<ul>
<li>格式如下：Method Request-URL HTTP-Version CRLF</li>
</ul>
<p><strong>举例</strong></p>
<ul>
<li>GET / HTTP/1.1 CRLF</li>
</ul>
<p><strong>请求方法</strong></p>
<ul>
<li>==GET== 请求获取Requesr-URI所标识的资源</li>
<li>==POST== 在Request-URI所标识的资源后附加薪的数据</li>
<li>==HEAD== 请求获取由Request-URI所标识的资源的响应消息报头</li>
<li>==PUT== 请求服务器存储一个资源,并用Request-URI作为其标识</li>
<li>==DELETE== 请求服务器删除Request-URI所标识的资源</li>
<li>==OPTIONS== 请求查询服务器的性能,或者查询与资源相关的选项和需求</li>
</ul>
<hr>
<h5 id="http协议-响应"><a href="#http协议-响应" class="headerlink" title="http协议-响应"></a>http协议-响应</h5><blockquote>
<p>组成格式：状态行、消息报头、响应正文</p>
</blockquote>
<p><strong>状态行</strong></p>
<ul>
<li>HTTP-Version Status-Code Reason-Phrase CRLF</li>
<li>例如：HTTP /1.1 200 OK</li>
</ul>
<p><strong>常用状态码</strong></p>
<ul>
<li>200 OK    //客户端请求成功</li>
<li>400 Bad Request   //客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized  //服务器收到请求,但是拒绝提供服务</li>
<li>404 Not Found //请求资源不存在</li>
<li>500 Internal Server Error //服务器发送不可预期的错误</li>
<li>503 Server Unavailable //服务器当前不能处理客户端的请求</li>
</ul>
<h4 id="Restful架构与其他架构的区别"><a href="#Restful架构与其他架构的区别" class="headerlink" title="Restful架构与其他架构的区别"></a>Restful架构与其他架构的区别</h4><h5 id="SOAP-WebService"><a href="#SOAP-WebService" class="headerlink" title="SOAP WebService"></a>SOAP WebService</h5><ul>
<li> WebService是一种跨编程语言和跨操作系统平台的远程调用技术。</li>
<li> WebService通过HTTP协议发送请求和接收结果时采用XML格式封装，并增加了一些特定的HTTP消息头，这些特定的HTTP消息头和XML内容格式就是SOAP协议。</li>
</ul>
<h6 id="效率和易用性"><a href="#效率和易用性" class="headerlink" title="效率和易用性"></a>效率和易用性</h6><ul>
<li><p> SOAP由于各种需求不断扩充其本身协议的内容，导致在SOAP处理方面的性能有所下降。同时在易用性方面以及学习成本上也有所<br>增加。</p>
</li>
<li><p>Restful由于其面向资源接口设计以及操作抽象简化了开发者的不良设计，同时也最大限度<br>的利用了Http最初的应用协议设计理念。</p>
<h6 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h6></li>
<li><p> Restful对于资源型服务接口来说很合适，同时特别适合对于效率要求很高，但是对于安全要求不高的场景。</p>
</li>
<li><p> SOAP的成熟性可以给需要提供给多开发语言的，对于安全性要求较高的接口设计带来便利。所以我觉得纯粹说什么设计模式将会占据主导地位没有什么意义，关键还是看应用场景。</p>
</li>
</ul>
<h4 id="如何设计Restful-API"><a href="#如何设计Restful-API" class="headerlink" title="如何设计Restful API"></a>如何设计Restful API</h4><h6 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h6><p>API与用户的通信协议，总是使用HTTPS协议。</p>
<h6 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h6><p>应该尽量将API部署在专用域名之下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com</span><br></pre></td></tr></table></figure>
<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.org/api/</span><br></pre></td></tr></table></figure>
<h6 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h6><p>应该将API的版本号放入URL。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/</span><br></pre></td></tr></table></figure>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<code>Github</code>采用这种做法。</p>
<h6 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h6><p>路径又称”终点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/zoos</span><br><span class="line">https://api.example.com/v1/animals</span><br><span class="line">https://api.example.com/v1/employees</span><br></pre></td></tr></table></figure>

<h6 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h6><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（CREATE）：在服务器新建一个资源。</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line">DELETE（DELETE）：从服务器删除资源。</span><br></pre></td></tr></table></figure>
<p>还有两个不常用的HTTP动词。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEAD：获取资源的元数据。</span><br><span class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</span><br></pre></td></tr></table></figure>
<p>下面是一些例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /zoos：列出所有动物园</span><br><span class="line">POST /zoos：新建一个动物园</span><br><span class="line">GET /zoos/ID：获取某个指定动物园的信息</span><br><span class="line">PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE /zoos/ID：删除某个动物园</span><br><span class="line">GET /zoos/ID/animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure>
<h6 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h6><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>
<h6 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h6><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</span><br><span class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</span><br><span class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure>
<p>状态码的完全列表参见<a target="_blank" rel="noopener" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">这里</a>。</p>
<h6 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h6><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: &quot;Invalid API key&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h6><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /collection：返回资源对象的列表（数组）</span><br><span class="line">GET /collection/resource：返回单个资源对象</span><br><span class="line">POST /collection：返回新生成的资源对象</span><br><span class="line">PUT /collection/resource：返回完整的资源对象</span><br><span class="line">PATCH /collection/resource：返回完整的资源对象</span><br><span class="line">DELETE /collection/resource：返回一个空文档</span><br></pre></td></tr></table></figure>

<h6 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h6><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;link&quot;: &#123;</span><br><span class="line">  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,</span><br><span class="line">  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;List of zoos&quot;,</span><br><span class="line">  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>
<p>Hypermedia API的设计被称为<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>。Github的API就是这种设计，访问<a target="_blank" rel="noopener" href="https://api.github.com/">api.github.com</a>会得到一个所有可用API的网址列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,</span><br><span class="line">  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a target="_blank" rel="noopener" href="https://api.github.com/user">api.github.com/user</a>，然后就得到了下面结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;message&quot;: &quot;Requires authentication&quot;,</span><br><span class="line">  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>
<h6 id="HTTP其他"><a href="#HTTP其他" class="headerlink" title="HTTP其他"></a>HTTP其他</h6><ul>
<li> API的身份认证应该使用OAuth 2.0框架。</li>
<li> 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a target="_blank" rel="noopener" href="https://www.imooc.com/learn/811">Restful API实战</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/restful_api">RESTful API 设计指南</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a><br><a target="_blank" rel="noopener" href="https://github.com/aisuhua/restful-api-design-references">RESTful API 设计参考文献列表</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2017/09/20/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-iOS%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%8E%A8%E6%B5%81%EF%BC%88%E5%85%AB%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/20/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-iOS%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%8E%A8%E6%B5%81%EF%BC%88%E5%85%AB%EF%BC%89/" class="post-title-link" itemprop="url">iOS直播技术学习笔记-iOS中实现推流（八）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-20 21:03:07" itemprop="dateCreated datePublished" datetime="2017-09-20T21:03:07+08:00">2017-09-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="推流演示"><a href="#推流演示" class="headerlink" title="推流演示"></a>推流演示</h1><h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3><h4 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h4><ul>
<li>Nginx介绍<ul>
<li>  Nginx是什么?</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231513139.png" alt="Nginx.png"><br>    *   简言之，Nginx本身是一个非常出色的HTTP服务器，具有占用内存少，高并发的特点。</p>
<ul>
<li>  Nginx安装</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1&gt; 将Nginx Clone到本地</span><br><span class="line">$ brew tap homebrew/nginx</span><br><span class="line">// 2&gt; 链接要执行的命令</span><br><span class="line">$ brew link pcre rtmp-nginx-module</span><br><span class="line">// 3&gt; 安装Nginx</span><br><span class="line">$ brew install nginx-full --with-rtmp-module</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>  记住安装配置文件的路径(/usr/local/etc/nginx/nginx.conf)</p>
</li>
<li><p>启动即可:</p>
<ul>
<li>  $ nginx</li>
<li>  在浏览器输入地址验证: <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a></li>
</ul>
</li>
<li><p>  配置Nginx，支持http协议拉流</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /hls &#123;</span><br><span class="line">        #Serve HLS config</span><br><span class="line">        types &#123;</span><br><span class="line">            application/vnd.apple.mpegurl    m3u8;</span><br><span class="line">            video/mp2t ts;</span><br><span class="line">        &#125;</span><br><span class="line">        root /usr/local/var/www;</span><br><span class="line">        add_header Cache-Control    no-cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  配置Nginx，支持rtmp协议推流</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        application rtmplive &#123;</span><br><span class="line">            live on;</span><br><span class="line">            max_connections 1024;</span><br><span class="line">        &#125;</span><br><span class="line">        application hls&#123;</span><br><span class="line">            live on;</span><br><span class="line">            hls on;</span><br><span class="line">            hls_path /usr/local/var/www/hls;</span><br><span class="line">            hls_fragment 1s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  重启Nginx: nginx -s reload</li>
</ul>
<h3 id="推流测试"><a href="#推流测试" class="headerlink" title="推流测试"></a>推流测试</h3><ul>
<li>推流至RTMP到服务器<ul>
<li>  生成地址: rtmp://localhost:1935/rtmplive/demo</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i story.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp://localhost:1935/rtmplive/demo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>推流至HLS到服务器<ul>
<li>  生成地址: <a target="_blank" rel="noopener" href="http://localhost:8080/hls/test.m3u8">http://localhost:8080/hls/test.m3u8</a></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i /Users/apple/Desktop/ffmepg/HLS切片/说出你的励志故事.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp://localhost:1935/hls/demo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="远程服务器配置"><a href="#远程服务器配置" class="headerlink" title="远程服务器配置"></a>远程服务器配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0&gt; 安装git</span><br><span class="line">1&gt; git clone srs</span><br><span class="line">2&gt; cd sis目录</span><br><span class="line">* git checkout 2.0release</span><br><span class="line">* git pull</span><br><span class="line">3&gt; 配置远程服务器环境</span><br><span class="line">* ./configure --disable-all --with-ssl --with-nginx --with-hls --with-http-callback --with-http-server --with-http-api --with-ffmpeg --with-transcode --with-librtmp --with-dvr &amp;&amp; make</span><br><span class="line">4&gt; 启动配置</span><br><span class="line">* ./objcs/srs -c conf/srs.conf</span><br><span class="line">* 查看pid: pgrep</span><br><span class="line">5&gt; 关闭进程</span><br><span class="line">* kill nginx/killall nginx</span><br><span class="line">6&gt; 推流可以播放hls/rtmp</span><br><span class="line">* 加载自己配置的conf文件srs/trunk/conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="iOS中实现推流"><a href="#iOS中实现推流" class="headerlink" title="iOS中实现推流"></a>iOS中实现推流</h1><h3 id="推流概述"><a href="#推流概述" class="headerlink" title="推流概述"></a>推流概述</h3><ul>
<li>  经过前面的讲解&amp;分析, 我们已经可以做到采集-美颜滤镜-视频编码-协议推流</li>
<li>  那么下面就需要真正实现iOS中的推流</li>
<li>  采用RTMP进行推流, 因为该协议实时性非常的高, 但是将Message封装成Trunk的过程非常麻烦, 所有我们这里直接采用框架实现推流.</li>
<li>常见的推流框架<ul>
<li>  Swift框架: lf.swift</li>
<li>  OC框架: LFLiveKit</li>
</ul>
</li>
</ul>
<h3 id="推流框架的使用"><a href="#推流框架的使用" class="headerlink" title="推流框架的使用"></a>推流框架的使用</h3><ul>
<li>  LFLiveKit是一个集成了视频采集-美颜-编码-推流为一体的框架,并且使用起来非常的简单, 我们可以在iOS中直接使用该框架进行推流</li>
<li>  使用方式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2017/09/16/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%83%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/16/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%83%EF%BC%89/" class="post-title-link" itemprop="url">iOS直播技术学习笔记-流媒体协议（七）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-16 22:00:54" itemprop="dateCreated datePublished" datetime="2017-09-16T22:00:54+08:00">2017-09-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="常见的流媒体协议"><a href="#常见的流媒体协议" class="headerlink" title="常见的流媒体协议"></a>常见的流媒体协议</h3><ul>
<li>常见的流媒体协议有很多比如:<ul>
<li>  RTP(Real-time Transport Protocol), 常用语电话会议, 网络电话等场景, 但是缺点是不提供网络保障</li>
<li>  RTCP(Real-time Transport Control Protocol), 是实时传输协议（RTP）的一个姐妹协议, 也常用于语电话会议, 网络电话等场景.</li>
<li>  RTMP(Real Time Streaming Protocol), RTMP是Adobe开发的协议</li>
<li>  HLS(HTTP Live Streaming)是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播</li>
</ul>
</li>
</ul>
<h3 id="HLS-HTTP-Live-Streaming"><a href="#HLS-HTTP-Live-Streaming" class="headerlink" title="HLS(HTTP Live Streaming)"></a>HLS(HTTP Live Streaming)</h3><ul>
<li>HTTP Live Streaming（HLS）是苹果公司实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播。原理上是将视频流分片成一系列HTTP下载文件。所以，HLS比RTMP有较高的延迟。HLS基于HTTP协议实现，传输内容包括两部分，一是M3U8描述文件，二是TS媒体文件<ul>
<li>  相对于常见的流媒体直播协议，例如RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。</li>
<li>  由此可见，基本上可以认为，HLS是以点播的技术方式来实现直播。</li>
</ul>
</li>
<li>工作流程为:<ul>
<li>  采集视频源和音频源的数据</li>
<li>  对原始数据进行H264编码和AAC编码</li>
<li>  视频和音频数据封装为MPEG-TS包</li>
<li>  HLS分段生成策略及m3u8索引文件</li>
<li>  HTTP传输协议传输数据</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231512124.png" alt="工作流程.png"></p>
<ul>
<li>  使用FFmpeg命令将mp4文件切换成m3u8&amp;ts切片</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 安装Homebrew</span><br><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">// 安装FFmpeg</span><br><span class="line">brew install ffmpeg</span><br><span class="line">// 执行转换命令</span><br><span class="line">ffmpeg -i XXX.mp4 -c:v libx264 -c:a copy -f hls XXX.m3u8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  m3u8索引头解析</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231512157.png" alt="m3u8索引头解析.png"></p>
<h3 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h3><ul>
<li>  RTMP协议是 Adobe 公司开发的一个基于TCP的应用层协议，Adobe 公司也公布了关于RTMP的规范</li>
<li>RTMP本质上是流协议，主要的优势是：<ul>
<li>  实时性高：RTMP的实时性在3秒之内，经过多层CDN节点分发后，实时性也在3秒左右,在一些实时性有要求的应用中以RTMP为主。</li>
<li>  支持加密：RTMPE和RTMPS为加密协议</li>
<li>  稳定性高：HTTP也很稳定，但HTTP是在协议上稳定稳定性不只是服务端的事情，在CDN分发，服务器管理，客户端的支持上</li>
</ul>
</li>
<li>RTMP的使用<ul>
<li>  RTMP协议也要客户端和服务器通过“握手”来建立基于传输层链接之上的RTMP Connection链接，在Connection链接上会传输一些控制信息</li>
<li>  TMP协议传输时会对数据做自己的格式化，这种格式的消息我们称之为RTMP Message</li>
<li>  而实际传输的时候为了更好地实现多路复用、分包和信息的公平性，发送端会把Message划分为带有Message ID的Chunk，每个Chunk可能是一个单独的Message，也可能是Message的一部分，在接受端会根据chunk中包含的data的长度，message id和message的长度把chunk还原成完整的Message，从而实现信息的收发。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2017/09/15/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-YUV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%EF%BC%88%E5%85%AD%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/15/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-YUV%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%EF%BC%88%E5%85%AD%EF%BC%89/" class="post-title-link" itemprop="url">iOS直播技术学习笔记-YUV颜色空间（六）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-15 20:10:48" itemprop="dateCreated datePublished" datetime="2017-09-15T20:10:48+08:00">2017-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="为什么学习YUV颜色空间"><a href="#为什么学习YUV颜色空间" class="headerlink" title="为什么学习YUV颜色空间"></a>为什么学习YUV颜色空间</h3><ul>
<li>  使用系统提供的接口获取到的音视频数据都保存在CMSampleBufferRef中, 使用GPUImamge获取到的音频数据为CMSampleBufferRef</li>
<li>CMSampleBufferRef<ul>
<li>  这个结构在iOS中表示一帧音频/视频数据</li>
<li>  它里面包含了这一帧数据的内容和格式, 我们可以把它的内容取出来，提取出/转换成 我们想要的数据</li>
<li>  代表视频的CMSampleBufferRef中保存的数据是yuv420格式的视频帧(我们在视频输出设置中将输出格式设为：kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange)</li>
<li>  代表音频的CMSampleBufferRef中保存的数据是PCM格式的音频帧</li>
</ul>
</li>
</ul>
<h3 id="yuv是什么？"><a href="#yuv是什么？" class="headerlink" title="yuv是什么？"></a>yuv是什么？</h3><ul>
<li>  视频是由一帧一帧的数据连接而成，而一帧视频数据其实就是一张图片。</li>
<li>yuv是一种图片储存格式，跟RGB格式类似。<ul>
<li>  RGB格式的图片很好理解，计算机中的大多数图片，都是以RGB格式存储的。</li>
<li>  yuv中，y表示亮度，单独只有y数据就可以形成一张图片，只不过这张图片是灰色的。u和v表示色差(u和v也被称为：Cb－蓝色差，Cr－红色差)</li>
</ul>
</li>
<li>为什么要yuv？<ul>
<li>  有一定历史原因，最早的电视信号，为了兼容黑白电视，采用的就是yuv格式。</li>
<li>  一张yuv的图像，去掉uv，只保留y，这张图片就是黑白的。</li>
<li>  而且yuv可以通过抛弃色差来进行带宽优化。</li>
<li>  比如yuv420格式图像相比RGB来说，要节省一半的字节大小，抛弃相邻的色差对于人眼来说，差别不大。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231511553.jpeg" alt="YUV颜色空间.jpg"></p>
<h3 id="YUV颜色存储格式"><a href="#YUV颜色存储格式" class="headerlink" title="YUV颜色存储格式"></a>YUV颜色存储格式</h3><ul>
<li>  常用的I420(YUV420P),NV12(YUV420SP),YV12（YUV420P）,NV21(YUV420SP)等都是属于YUV420，NV12是一种两平面存储方式，Y为一个平面，交错的UV为另一个平面</li>
<li>  通常，用来远程传输的是I420数据，而本地摄像头采集的是NV12数据。（iOS）</li>
<li>  所有在真正编码的过程中, 需要将NV12数据转成I420数据进行编码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2017/09/13/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A1%AC%E7%BC%96%E7%A0%81-%E8%BD%AF%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/13/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A1%AC%E7%BC%96%E7%A0%81-%E8%BD%AF%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">iOS直播技术学习笔记-硬编码&软编码实现（五）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-13 19:08:55" itemprop="dateCreated datePublished" datetime="2017-09-13T19:08:55+08:00">2017-09-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="iOS硬编码实现"><a href="#iOS硬编码实现" class="headerlink" title="iOS硬编码实现"></a>iOS硬编码实现</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>  在上一篇中，我们已经知道iOS编码的一些概念知识，从现在开始，我们可以正式对采集到的视频进行编码</li>
<li>  这里我们重点介绍硬编码的使用方式，也就是VideoToolBox框架的使用</li>
<li>  编码的流程：采集–&gt; 获取到视频帧–&gt; 对视频帧进行编码 –&gt; 获取到视频帧信息 –&gt; 将编码后的数据以NALU方式写入到文件</li>
</ul>
<h3 id="视频采集"><a href="#视频采集" class="headerlink" title="视频采集"></a>视频采集</h3><ul>
<li>  视频采集我们已经在前面进行了介绍和学习，所有这里就直接贴代码，只是我对采集过程进行了一些简单的封装</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231509594.png" alt="视频采集.png"></p>
<h3 id="视频硬件编码"><a href="#视频硬件编码" class="headerlink" title="视频硬件编码"></a>视频硬件编码</h3><ul>
<li>初始化压缩编码会话（VTCompressionSessionRef）<ul>
<li>  在VideoToolbox框架的使用过程中，基本都是C语言函数</li>
</ul>
</li>
<li>初始化后通过<code>VTSessionSetProperty</code>设置对象属性<ul>
<li>  编码方式：H.264编码</li>
<li>  帧率：每秒钟多少帧画面</li>
<li>  码率：单位时间内保存的数据量</li>
<li>  关键帧（GOPsize)间隔：多少帧为一个GOP</li>
</ul>
</li>
<li>  准备编码</li>
<li>  代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupVideoSession &#123;</span><br><span class="line">    // 1.用于记录当前是第几帧数据(画面帧数非常多)</span><br><span class="line">    self.frameID = 0;</span><br><span class="line"></span><br><span class="line">    // 2.录制视频的宽度&amp;高度</span><br><span class="line">    int width = [UIScreen mainScreen].bounds.size.width;</span><br><span class="line">    int height = [UIScreen mainScreen].bounds.size.height;</span><br><span class="line"></span><br><span class="line">    // 3.创建CompressionSession对象,该对象用于对画面进行编码</span><br><span class="line">    // kCMVideoCodecType_H264 : 表示使用h.264进行编码</span><br><span class="line">    // didCompressH264 : 当一次编码结束会在该函数进行回调,可以在该函数中将数据,写入文件中</span><br><span class="line">    VTCompressionSessionCreate(NULL, width, height, kCMVideoCodecType_H264, NULL, NULL, NULL, didCompressH264, (__bridge void *)(self),  &amp;_compressionSession);</span><br><span class="line"></span><br><span class="line">    // 4.设置实时编码输出（直播必然是实时输出,否则会有延迟）</span><br><span class="line">    VTSessionSetProperty(self.compressionSession, kVTCompressionPropertyKey_RealTime, kCFBooleanTrue);</span><br><span class="line"></span><br><span class="line">    // 5.设置期望帧率(每秒多少帧,如果帧率过低,会造成画面卡顿)</span><br><span class="line">    int fps = 30;</span><br><span class="line">    CFNumberRef  fpsRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &amp;fps);</span><br><span class="line">    VTSessionSetProperty(self.compressionSession, kVTCompressionPropertyKey_ExpectedFrameRate, fpsRef);</span><br><span class="line"></span><br><span class="line">    // 6.设置码率(码率: 编码效率, 码率越高,则画面越清晰, 如果码率较低会引起马赛克 --&gt; 码率高有利于还原原始画面,但是也不利于传输)</span><br><span class="line">    int bitRate = 800*1024;</span><br><span class="line">    CFNumberRef bitRateRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;bitRate);</span><br><span class="line">    VTSessionSetProperty(self.compressionSession, kVTCompressionPropertyKey_AverageBitRate, bitRateRef);</span><br><span class="line">    NSArray *limit = @[@(bitRate * 1.5/8), @(1)];</span><br><span class="line">    VTSessionSetProperty(self.compressionSession, kVTCompressionPropertyKey_DataRateLimits, (__bridge CFArrayRef)limit);</span><br><span class="line"></span><br><span class="line">    // 7.设置关键帧（GOPsize)间隔</span><br><span class="line">    int frameInterval = 30;</span><br><span class="line">    CFNumberRef  frameIntervalRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &amp;frameInterval);</span><br><span class="line">    VTSessionSetProperty(self.compressionSession, kVTCompressionPropertyKey_MaxKeyFrameInterval, frameIntervalRef);</span><br><span class="line"></span><br><span class="line">    // 8.基本设置结束, 准备进行编码</span><br><span class="line">    VTCompressionSessionPrepareToEncodeFrames(self.compressionSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将输入的帧进行编码<ul>
<li>  将CMSampleBufferRef转成CVImageBufferRef</li>
<li>  开始对CVImageBufferRef进行编码</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)encodeSampleBuffer:(CMSampleBufferRef)sampleBuffer &#123;</span><br><span class="line">    // 1.将sampleBuffer转成imageBuffer</span><br><span class="line">    CVImageBufferRef imageBuffer = (CVImageBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer);</span><br><span class="line"></span><br><span class="line">    // 2.根据当前的帧数,创建CMTime的时间</span><br><span class="line">    CMTime presentationTimeStamp = CMTimeMake(self.frameID++, 1000);</span><br><span class="line">    VTEncodeInfoFlags flags;</span><br><span class="line"></span><br><span class="line">    // 3.开始编码该帧数据</span><br><span class="line">    OSStatus statusCode = VTCompressionSessionEncodeFrame(self.compressionSession,</span><br><span class="line">                                                          imageBuffer,</span><br><span class="line">                                                          presentationTimeStamp,</span><br><span class="line">                                                          kCMTimeInvalid,</span><br><span class="line">                                                          NULL, (__bridge void * _Nullable)(self), &amp;flags);</span><br><span class="line">    if (statusCode == noErr) &#123;</span><br><span class="line">        NSLog(@&quot;H264: VTCompressionSessionEncodeFrame Success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当编码成功后，将编码后的码流写入文件<ul>
<li>  编码成功后会回调之前输入的函数</li>
<li>1&gt; 先判断是否是关键帧：<ul>
<li>  如果是关键帧，则需要在写入关键帧之前，先写入PPS、SPS的NALU</li>
<li>  取出PPS、SPS数据，并且封装成NALU单元，写入文件</li>
</ul>
</li>
<li>  2&gt; 将I帧、P帧、B帧分别封装成NALU单元写入文件</li>
<li>  写入后，数据存储方式：</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231509614.png" alt="数据存储方式.png"></p>
<ul>
<li>  代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">// 编码完成回调</span><br><span class="line">void didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer) &#123;</span><br><span class="line"></span><br><span class="line">    // 1.判断状态是否等于没有错误</span><br><span class="line">    if (status != noErr) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.根据传入的参数获取对象</span><br><span class="line">    VideoEncoder* encoder = (__bridge VideoEncoder*)outputCallbackRefCon;</span><br><span class="line"></span><br><span class="line">    // 3.判断是否是关键帧</span><br><span class="line">    bool isKeyframe = !CFDictionaryContainsKey( (CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, true), 0)), kCMSampleAttachmentKey_NotSync);</span><br><span class="line">    // 判断当前帧是否为关键帧</span><br><span class="line">    // 获取sps &amp; pps数据</span><br><span class="line">    if (isKeyframe)</span><br><span class="line">    &#123;</span><br><span class="line">        // 获取编码后的信息（存储于CMFormatDescriptionRef中）</span><br><span class="line">        CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);</span><br><span class="line"></span><br><span class="line">        // 获取SPS信息</span><br><span class="line">        size_t sparameterSetSize, sparameterSetCount;</span><br><span class="line">        const uint8_t *sparameterSet;</span><br><span class="line">        CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparameterSetSize, &amp;sparameterSetCount, 0 );</span><br><span class="line"></span><br><span class="line">        // 获取PPS信息</span><br><span class="line">        size_t pparameterSetSize, pparameterSetCount;</span><br><span class="line">        const uint8_t *pparameterSet;</span><br><span class="line">        CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, 0 );</span><br><span class="line"></span><br><span class="line">        // 装sps/pps转成NSData，以方便写入文件</span><br><span class="line">        NSData *sps = [NSData dataWithBytes:sparameterSet length:sparameterSetSize];</span><br><span class="line">        NSData *pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize];</span><br><span class="line"></span><br><span class="line">        // 写入文件</span><br><span class="line">        [encoder gotSpsPps:sps pps:pps];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取数据块</span><br><span class="line">    CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);</span><br><span class="line">    size_t length, totalLength;</span><br><span class="line">    char *dataPointer;</span><br><span class="line">    OSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &amp;length, &amp;totalLength, &amp;dataPointer);</span><br><span class="line">    if (statusCodeRet == noErr) &#123;</span><br><span class="line">        size_t bufferOffset = 0;</span><br><span class="line">        static const int AVCCHeaderLength = 4; // 返回的nalu数据前四个字节不是0001的startcode，而是大端模式的帧长度length</span><br><span class="line"></span><br><span class="line">        // 循环获取nalu数据</span><br><span class="line">        while (bufferOffset &lt; totalLength - AVCCHeaderLength) &#123;</span><br><span class="line">            uint32_t NALUnitLength = 0;</span><br><span class="line">            // Read the NAL unit length</span><br><span class="line">            memcpy(&amp;NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength);</span><br><span class="line"></span><br><span class="line">            // 从大端转系统端</span><br><span class="line">            NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</span><br><span class="line"></span><br><span class="line">            NSData* data = [[NSData alloc] initWithBytes:(dataPointer + bufferOffset + AVCCHeaderLength) length:NALUnitLength];</span><br><span class="line">            [encoder gotEncodedData:data isKeyFrame:isKeyframe];</span><br><span class="line"></span><br><span class="line">            // 移动到写一个块，转成NALU单元</span><br><span class="line">            // Move to the next NAL unit in the block buffer</span><br><span class="line">            bufferOffset += AVCCHeaderLength + NALUnitLength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)gotSpsPps:(NSData*)sps pps:(NSData*)pps</span><br><span class="line">&#123;</span><br><span class="line">    // 1.拼接NALU的header</span><br><span class="line">    const char bytes[] = &quot;\x00\x00\x00\x01&quot;;</span><br><span class="line">    size_t length = (sizeof bytes) - 1;</span><br><span class="line">    NSData *ByteHeader = [NSData dataWithBytes:bytes length:length];</span><br><span class="line"></span><br><span class="line">    // 2.将NALU的头&amp;NALU的体写入文件</span><br><span class="line">    [self.fileHandle writeData:ByteHeader];</span><br><span class="line">    [self.fileHandle writeData:sps];</span><br><span class="line">    [self.fileHandle writeData:ByteHeader];</span><br><span class="line">    [self.fileHandle writeData:pps];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)gotEncodedData:(NSData*)data isKeyFrame:(BOOL)isKeyFrame</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;gotEncodedData %d&quot;, (int)[data length]);</span><br><span class="line">    if (self.fileHandle != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        const char bytes[] = &quot;\x00\x00\x00\x01&quot;;</span><br><span class="line">        size_t length = (sizeof bytes) - 1; //string literals have implicit trailing &#x27;\0&#x27;</span><br><span class="line">        NSData *ByteHeader = [NSData dataWithBytes:bytes length:length];</span><br><span class="line">        [self.fileHandle writeData:ByteHeader];</span><br><span class="line">        [self.fileHandle writeData:data];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="iOS视频软编码"><a href="#iOS视频软编码" class="headerlink" title="iOS视频软编码"></a>iOS视频软编码</h1><h3 id="软编码介绍"><a href="#软编码介绍" class="headerlink" title="软编码介绍"></a>软编码介绍</h3><ul>
<li>  软编码主要是利用CPU进行编码的过程, 具体的编码通常会用FFmpeg+x264</li>
<li>FFmpeg<ul>
<li>  FFmpeg是一个非常强大的音视频处理库,包括视频采集功能、视频格式转换、视频抓图、给视频加水印等。</li>
<li>  FFmpeg在Linux平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括Windows、Mac OS X等。</li>
</ul>
</li>
<li>X264<ul>
<li>  H.264是ITU制定的视频编码标准</li>
<li>  而x264是一个开源的H.264/MPEG-4 AVC视频编码函数库[1] ，是最好的有损视频编码器,里面集成了非常多优秀的算法用于视频编码.</li>
</ul>
</li>
<li>关于软编码推荐博客(雷霄骅)<ul>
<li>  <a target="_blank" rel="noopener" href="http://blog.csdn.net/leixiaohua1020">http://blog.csdn.net/leixiaohua1020</a></li>
</ul>
</li>
</ul>
<h3 id="Mac安装-使用FFmpeg"><a href="#Mac安装-使用FFmpeg" class="headerlink" title="Mac安装/使用FFmpeg"></a>Mac安装/使用FFmpeg</h3><ul>
<li>安装<ul>
<li>  ruby -e “$(curl -fsSkL raw.github.com/mxcl/homebrew/go)”</li>
<li>  brew install ffmpeg</li>
</ul>
</li>
<li>简单使用<ul>
<li>  转化格式: ffmpeg -i story.webm story.mp4</li>
<li>  分离视频: ffmpeg -i story.mp4 -vcodec copy -an demo.mp4</li>
<li>  分离音频: ffmpeg -i story.mp4 -acodec copy -vn demo.aac</li>
</ul>
</li>
</ul>
<h3 id="编译FFmpeg-iOS"><a href="#编译FFmpeg-iOS" class="headerlink" title="编译FFmpeg(iOS)"></a>编译FFmpeg(iOS)</h3><ul>
<li>下载编译FFmpeg所需要的脚本文件gas-preprocessor.pl<ul>
<li>  下载地址: <a target="_blank" rel="noopener" href="https://github.com/mansr/gas-preprocessor">https://github.com/mansr/gas-preprocessor</a></li>
<li>  复制gas-preprocessor.pl到/usr/sbin下，（这个应该是复制到/usr/local/bin）</li>
<li>  修改文件权限：chmod 777 /usr/local/bin/gas-preprocessor.pl</li>
</ul>
</li>
<li>下载脚本FFmpeg脚本<ul>
<li>  地址: <a target="_blank" rel="noopener" href="https://github.com/kewlbear/FFmpeg-iOS-build-script">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></li>
<li>  解压，找到文件 build-ffmpeg.sh</li>
<li>  执行服本文件：./build-ffmpeg.sh</li>
</ul>
</li>
</ul>
<h3 id="编译X264"><a href="#编译X264" class="headerlink" title="编译X264"></a>编译X264</h3><ul>
<li>下载x264<ul>
<li>  x264官网 下载x264源码，将其文件夹名称改为x264</li>
<li>  <a target="_blank" rel="noopener" href="http://www.videolan.org/developers/x264.html">http://www.videolan.org/developers/x264.html</a></li>
</ul>
</li>
<li>  下载gas-preprocessor(FFmpeg编译时已经下载过)</li>
<li>下载x264 build shell<ul>
<li>  下载build-x264.sh 将文件build-x264.sh放在x264同一级目录里面，注意不是放在x264文件夹里面。</li>
<li>  <a target="_blank" rel="noopener" href="https://github.com/kewlbear/x264-ios">https://github.com/kewlbear/x264-ios</a></li>
</ul>
</li>
<li>修改权限/执行脚本<ul>
<li>  sudo chmod u+x build-x264.sh</li>
<li>  sudo ./build-x264.sh</li>
</ul>
</li>
</ul>
<h3 id="iOS项目中集成FFmpeg"><a href="#iOS项目中集成FFmpeg" class="headerlink" title="iOS项目中集成FFmpeg"></a>iOS项目中集成FFmpeg</h3><ul>
<li>  将编译好的文件夹拖入到工程中</li>
<li>  添加依赖库: libiconv.dylib/libz.dylib/libbz2.dylib/CoreMedia.framework/AVFoundation.framework</li>
<li>  初始化编码器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  设置X264</span><br><span class="line"> */</span><br><span class="line">- (int)setX264ResourceWithVideoWidth:(int)width height:(int)height bitrate:(int)bitrate</span><br><span class="line">&#123;</span><br><span class="line">    // 1.默认从第0帧开始(记录当前的帧数)</span><br><span class="line">    framecnt = 0;</span><br><span class="line"></span><br><span class="line">    // 2.记录传入的宽度&amp;高度</span><br><span class="line">    encoder_h264_frame_width = width;</span><br><span class="line">    encoder_h264_frame_height = height;</span><br><span class="line"></span><br><span class="line">    // 3.注册FFmpeg所有编解码器(无论编码还是解码都需要该步骤)</span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    // 4.初始化AVFormatContext: 用作之后写入视频帧并编码成 h264，贯穿整个工程当中(释放资源时需要销毁)</span><br><span class="line">    pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    // 5.设置输出文件的路径</span><br><span class="line">    fmt = av_guess_format(NULL, out_file, NULL);</span><br><span class="line">    pFormatCtx-&gt;oformat = fmt;</span><br><span class="line"></span><br><span class="line">    // 6.打开文件的缓冲区输入输出，flags 标识为  AVIO_FLAG_READ_WRITE ，可读写</span><br><span class="line">    if (avio_open(&amp;pFormatCtx-&gt;pb, out_file, AVIO_FLAG_READ_WRITE) &lt; 0)&#123;</span><br><span class="line">        printf(&quot;Failed to open output file! \n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 7.创建新的输出流, 用于写入文件</span><br><span class="line">    video_st = avformat_new_stream(pFormatCtx, 0);</span><br><span class="line"></span><br><span class="line">    // 8.设置 20 帧每秒 ，也就是 fps 为 20</span><br><span class="line">    video_st-&gt;time_base.num = 1;</span><br><span class="line">    video_st-&gt;time_base.den = 25;</span><br><span class="line"></span><br><span class="line">    if (video_st==NULL)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 9.pCodecCtx 用户存储编码所需的参数格式等等</span><br><span class="line">    // 9.1.从媒体流中获取到编码结构体，他们是一一对应的关系，一个 AVStream 对应一个  AVCodecContext</span><br><span class="line">    pCodecCtx = video_st-&gt;codec;</span><br><span class="line"></span><br><span class="line">    // 9.2.设置编码器的编码格式(是一个id)，每一个编码器都对应着自己的 id，例如 h264 的编码 id 就是 AV_CODEC_ID_H264</span><br><span class="line">    pCodecCtx-&gt;codec_id = fmt-&gt;video_codec;</span><br><span class="line"></span><br><span class="line">    // 9.3.设置编码类型为 视频编码</span><br><span class="line">    pCodecCtx-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line"></span><br><span class="line">    // 9.4.设置像素格式为 yuv 格式</span><br><span class="line">    pCodecCtx-&gt;pix_fmt = PIX_FMT_YUV420P;</span><br><span class="line"></span><br><span class="line">    // 9.5.设置视频的宽高</span><br><span class="line">    pCodecCtx-&gt;width = encoder_h264_frame_width;</span><br><span class="line">    pCodecCtx-&gt;height = encoder_h264_frame_height;</span><br><span class="line"></span><br><span class="line">    // 9.6.设置帧率</span><br><span class="line">    pCodecCtx-&gt;time_base.num = 1;</span><br><span class="line">    pCodecCtx-&gt;time_base.den = 15;</span><br><span class="line"></span><br><span class="line">    // 9.7.设置码率（比特率）</span><br><span class="line">    pCodecCtx-&gt;bit_rate = bitrate;</span><br><span class="line"></span><br><span class="line">    // 9.8.视频质量度量标准(常见qmin=10, qmax=51)</span><br><span class="line">    pCodecCtx-&gt;qmin = 10;</span><br><span class="line">    pCodecCtx-&gt;qmax = 51;</span><br><span class="line"></span><br><span class="line">    // 9.9.设置图像组层的大小(GOP--&gt;两个I帧之间的间隔)</span><br><span class="line">    pCodecCtx-&gt;gop_size = 250;</span><br><span class="line"></span><br><span class="line">    // 9.10.设置 B 帧最大的数量，B帧为视频图片空间的前后预测帧， B 帧相对于 I、P 帧来说，压缩率比较大，也就是说相同码率的情况下，</span><br><span class="line">    // 越多 B 帧的视频，越清晰，现在很多打视频网站的高清视频，就是采用多编码 B 帧去提高清晰度，</span><br><span class="line">    // 但同时对于编解码的复杂度比较高，比较消耗性能与时间</span><br><span class="line">    pCodecCtx-&gt;max_b_frames = 5;</span><br><span class="line"></span><br><span class="line">    // 10.可选设置</span><br><span class="line">    AVDictionary *param = 0;</span><br><span class="line">    // H.264</span><br><span class="line">    if(pCodecCtx-&gt;codec_id == AV_CODEC_ID_H264) &#123;</span><br><span class="line">        // 通过--preset的参数调节编码速度和质量的平衡。</span><br><span class="line">        av_dict_set(&amp;param, &quot;preset&quot;, &quot;slow&quot;, 0);</span><br><span class="line"></span><br><span class="line">        // 通过--tune的参数值指定片子的类型，是和视觉优化的参数，或有特别的情况。</span><br><span class="line">        // zerolatency: 零延迟，用在需要非常低的延迟的情况下，比如视频直播的编码</span><br><span class="line">        av_dict_set(&amp;param, &quot;tune&quot;, &quot;zerolatency&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 11.输出打印信息，内部是通过printf函数输出（不需要输出可以注释掉该局）</span><br><span class="line">    av_dump_format(pFormatCtx, 0, out_file, 1);</span><br><span class="line"></span><br><span class="line">    // 12.通过 codec_id 找到对应的编码器</span><br><span class="line">    pCodec = avcodec_find_encoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    if (!pCodec) &#123;</span><br><span class="line">        printf(&quot;Can not find encoder! \n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 13.打开编码器，并设置参数 param</span><br><span class="line">    if (avcodec_open2(pCodecCtx, pCodec,&amp;param) &lt; 0) &#123;</span><br><span class="line">        printf(&quot;Failed to open encoder! \n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 13.初始化原始数据对象: AVFrame</span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    // 14.通过像素格式(这里为 YUV)获取图片的真实大小，例如将 480 * 720 转换成 int 类型</span><br><span class="line">    avpicture_fill((AVPicture *)pFrame, picture_buf, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line">    // 15.h264 封装格式的文件头部，基本上每种编码都有着自己的格式的头部，想看具体实现的同学可以看看 h264 的具体实现</span><br><span class="line">    avformat_write_header(pFormatCtx, NULL);</span><br><span class="line"></span><br><span class="line">    // 16.创建编码后的数据 AVPacket 结构体来存储 AVFrame 编码后生成的数据</span><br><span class="line">    av_new_packet(&amp;pkt, picture_size);</span><br><span class="line"></span><br><span class="line">    // 17.设置 yuv 数据中 y 图的宽高</span><br><span class="line">    y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  编码每一帧数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 将CMSampleBufferRef格式的数据编码成h264并写入文件</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">- (void)encoderToH264:(CMSampleBufferRef)sampleBuffer</span><br><span class="line">&#123;</span><br><span class="line">    // 1.通过CMSampleBufferRef对象获取CVPixelBufferRef对象</span><br><span class="line">    CVPixelBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);</span><br><span class="line"></span><br><span class="line">    // 2.锁定imageBuffer内存地址开始进行编码</span><br><span class="line">    if (CVPixelBufferLockBaseAddress(imageBuffer, 0) == kCVReturnSuccess) &#123;</span><br><span class="line">        // 3.从CVPixelBufferRef读取YUV的值</span><br><span class="line">        // NV12和NV21属于YUV格式，是一种two-plane模式，即Y和UV分为两个Plane，但是UV（CbCr）为交错存储，而不是分为三个plane</span><br><span class="line">        // 3.1.获取Y分量的地址</span><br><span class="line">        UInt8 *bufferPtr = (UInt8 *)CVPixelBufferGetBaseAddressOfPlane(imageBuffer,0);</span><br><span class="line">        // 3.2.获取UV分量的地址</span><br><span class="line">        UInt8 *bufferPtr1 = (UInt8 *)CVPixelBufferGetBaseAddressOfPlane(imageBuffer,1);</span><br><span class="line"></span><br><span class="line">        // 3.3.根据像素获取图片的真实宽度&amp;高度</span><br><span class="line">        size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class="line">        size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class="line">        // 获取Y分量长度</span><br><span class="line">        size_t bytesrow0 = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer,0);</span><br><span class="line">        size_t bytesrow1  = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer,1);</span><br><span class="line">        UInt8 *yuv420_data = (UInt8 *)malloc(width * height *3/2);</span><br><span class="line"></span><br><span class="line">        /* convert NV12 data to YUV420*/</span><br><span class="line">        // 3.4.将NV12数据转成YUV420数据</span><br><span class="line">        UInt8 *pY = bufferPtr ;</span><br><span class="line">        UInt8 *pUV = bufferPtr1;</span><br><span class="line">        UInt8 *pU = yuv420_data + width*height;</span><br><span class="line">        UInt8 *pV = pU + width*height/4;</span><br><span class="line">        for(int i =0;i&lt;height;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            memcpy(yuv420_data+i*width,pY+i*bytesrow0,width);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0;j&lt;height/2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i =0;i&lt;width/2;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                *(pU++) = pUV[i&lt;&lt;1];</span><br><span class="line">                *(pV++) = pUV[(i&lt;&lt;1) + 1];</span><br><span class="line">            &#125;</span><br><span class="line">            pUV+=bytesrow1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3.5.分别读取YUV的数据</span><br><span class="line">        picture_buf = yuv420_data;</span><br><span class="line">        pFrame-&gt;data[0] = picture_buf;              // Y</span><br><span class="line">        pFrame-&gt;data[1] = picture_buf+ y_size;      // U</span><br><span class="line">        pFrame-&gt;data[2] = picture_buf+ y_size*5/4;  // V</span><br><span class="line"></span><br><span class="line">        // 4.设置当前帧</span><br><span class="line">        pFrame-&gt;pts = framecnt;</span><br><span class="line">        int got_picture = 0;</span><br><span class="line"></span><br><span class="line">        // 4.设置宽度高度以及YUV各式</span><br><span class="line">        pFrame-&gt;width = encoder_h264_frame_width;</span><br><span class="line">        pFrame-&gt;height = encoder_h264_frame_height;</span><br><span class="line">        pFrame-&gt;format = PIX_FMT_YUV420P;</span><br><span class="line"></span><br><span class="line">        // 5.对编码前的原始数据(AVFormat)利用编码器进行编码，将 pFrame 编码后的数据传入pkt 中</span><br><span class="line">        int ret = avcodec_encode_video2(pCodecCtx, &amp;pkt, pFrame, &amp;got_picture);</span><br><span class="line">        if(ret &lt; 0) &#123;</span><br><span class="line">            printf(&quot;Failed to encode! \n&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 6.编码成功后写入 AVPacket 到 输入输出数据操作着 pFormatCtx 中，当然，记得释放内存</span><br><span class="line">        if (got_picture==1) &#123;</span><br><span class="line">            framecnt++;</span><br><span class="line">            pkt.stream_index = video_st-&gt;index;</span><br><span class="line">            ret = av_write_frame(pFormatCtx, &amp;pkt);</span><br><span class="line">            av_free_packet(&amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 7.释放yuv数据</span><br><span class="line">        free(yuv420_data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  释放资源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 释放资源</span><br><span class="line"> */</span><br><span class="line">- (void)freeX264Resource</span><br><span class="line">&#123;</span><br><span class="line">    // 1.释放AVFormatContext</span><br><span class="line">    int ret = flush_encoder(pFormatCtx,0);</span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">        printf(&quot;Flushing encoder failed\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.将还未输出的AVPacket输出出来</span><br><span class="line">    av_write_trailer(pFormatCtx);</span><br><span class="line"></span><br><span class="line">    // 3.关闭资源</span><br><span class="line">    if (video_st)&#123;</span><br><span class="line">        avcodec_close(video_st-&gt;codec);</span><br><span class="line">        av_free(pFrame);</span><br><span class="line">    &#125;</span><br><span class="line">    avio_close(pFormatCtx-&gt;pb);</span><br><span class="line">    avformat_free_context(pFormatCtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int flush_encoder(AVFormatContext *fmt_ctx,unsigned int stream_index)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    int got_frame;</span><br><span class="line">    AVPacket enc_pkt;</span><br><span class="line">    if (!(fmt_ctx-&gt;streams[stream_index]-&gt;codec-&gt;codec-&gt;capabilities &amp;</span><br><span class="line">          CODEC_CAP_DELAY))</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        enc_pkt.data = NULL;</span><br><span class="line">        enc_pkt.size = 0;</span><br><span class="line">        av_init_packet(&amp;enc_pkt);</span><br><span class="line">        ret = avcodec_encode_video2 (fmt_ctx-&gt;streams[stream_index]-&gt;codec, &amp;enc_pkt,</span><br><span class="line">                                     NULL, &amp;got_frame);</span><br><span class="line">        av_frame_free(NULL);</span><br><span class="line">        if (ret &lt; 0)</span><br><span class="line">            break;</span><br><span class="line">        if (!got_frame)&#123;</span><br><span class="line">            ret=0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = av_write_frame(fmt_ctx, &amp;enc_pkt);</span><br><span class="line">        if (ret &lt; 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2017/09/12/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E4%BB%8B%E7%BB%8D%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/12/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E4%BB%8B%E7%BB%8D%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">iOS直播技术学习笔记-视频编码介绍（四）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-12 19:04:55" itemprop="dateCreated datePublished" datetime="2017-09-12T19:04:55+08:00">2017-09-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="为什么进行压缩编码"><a href="#为什么进行压缩编码" class="headerlink" title="为什么进行压缩编码?"></a>为什么进行压缩编码?</h3><ul>
<li>视频是由一帧帧的图像组成(见实例)<ul>
<li>  比如一张Gif图片其实就可以被分解成若干张单独的图片<br><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231505609" alt="img"></li>
<li>  分别出的图片<br><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231505317.png" alt="2.png"></li>
</ul>
</li>
<li>未经压缩的视频的数据量巨大<ul>
<li>  比如:录音一分钟视频, 需要多大的空间来保存了?</li>
<li>  1&gt; 为了不让用户感受到卡顿效果, 1秒钟之内至少需要16帧画面(正常开发通常会采集30帧)</li>
<li>  2&gt; 假如该视频是一个1280*720分辨率的视频(正常情况下会比这个大很多)</li>
<li>  结果:1280_720_16*60≈843.75M</li>
<li>  如果帧率更高、分辨率更高、加上音频，那么一分钟的视频是多大呢？</li>
</ul>
</li>
<li>结论：<ul>
<li>  不经过压缩编码的视频，根本没办法保存，更何况网络中的传输</li>
<li>  视频录制完成后，要先编码，再传输，在解码，再播放（重现）</li>
</ul>
</li>
</ul>
<h3 id="为什么视频可以压缩编码？"><a href="#为什么视频可以压缩编码？" class="headerlink" title="为什么视频可以压缩编码？"></a>为什么视频可以压缩编码？</h3><ul>
<li><p>存在冗余信息</p>
<ul>
<li>  空间冗余：图像相邻像素之间有较强的相关性</li>
<li>  时间冗余：视频序列的相邻图像之间内容相似</li>
<li>  视觉冗余：人的视觉系统对某些细节不敏感</li>
<li>  等等冗余信息</li>
</ul>
</li>
<li><p>空间冗余</p>
<ul>
<li>  空间冗余是指在同一张图像中，有很多像素点表示的信息是完全一样的</li>
<li>  如果对每一个像素进行单独的存储，必然会非常浪费空间，也完全没有必要</li>
<li>  如图：<br><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231505390.png" alt="空间冗余.png"></li>
</ul>
</li>
<li><p>时间冗余</p>
<ul>
<li>  时间冗余是指多张图像之间，有非常多的相关性，由于一些小运动造成了细小差别</li>
<li>  如果对每张图像进行单独的像素存储，在下一张图片中又出现了相同的。那么相当于很多像素都存储了多份，必然会非常浪费空间，也是完全没有必要的</li>
<li>  如图：<br><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231505432.jpeg" alt="时间冗余.jpg"></li>
</ul>
</li>
<li><p>视觉冗余</p>
<ul>
<li>人类视觉系统HVS<ul>
<li>  对高频信息不敏感</li>
<li>  对高对比度更敏感</li>
<li>  对亮度信息比色度信息更敏感</li>
<li>  对运动的信息更敏感</li>
</ul>
</li>
<li>数字视频系统的设计应该考虑HVS的特点：<ul>
<li>  丢弃高频信息，只编码低频信息</li>
<li>  提高边缘信息的主观质量</li>
<li>  降低色度的解析度</li>
<li>  对感兴趣区域（Region of Interesting，ROI）进行特殊处理</li>
</ul>
</li>
<li>  如图：<br><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231507311" alt="视觉冗余"></li>
</ul>
</li>
<li><p>结论：</p>
<ul>
<li>  经过一系列的去处冗余信息，可以大大的降低视频的数据量</li>
<li>  更利于视频的保存、传输</li>
<li>  去除冗余信息的过程，我们就称之为压缩编码</li>
</ul>
</li>
</ul>
<h3 id="压缩编码的标准"><a href="#压缩编码的标准" class="headerlink" title="压缩编码的标准"></a>压缩编码的标准</h3><ul>
<li>为什么需要视频压缩编码标准<ul>
<li>  目前，我们已经非常清楚，视频在存储&amp;传输过程中，存在非常多的冗余信息，我们需要去除这些冗余信息</li>
<li>  但是，如果每个人按照自己的方式去编码，那么当我们需要还原原始数据时，很难知道对方是如何编码的</li>
<li>  比如：某主播在斗鱼采用iPhone手机进行直播，手机录制了主播大量的画面，为了便于传输，需要程序对视频进行压缩编码，但是他想当然的按照自己的某种算法进行了压缩，并且将数据传递给了服务器，服务器拿到数据之后，进行数据分发给了各个客户端：Android、iOS、Win、Web、Mac等等客户端，这个时候每个客户端需要知道对方的压缩算法，才能将数据进行还原，但是因为当时客户端是想当然的就行压缩编码的，并且也不能保证他的方式效率，而且有一点误差可能会造成画面无法还原的后果。</li>
<li>  因此，视频编码必须制定一个大家都认同的标准</li>
</ul>
</li>
<li>标准化组织：<ul>
<li>  ITU：International Telecommunications Union VECG：Video Coding Experts Group（国际电传视讯联盟）</li>
<li>  ISO：International Standards Organization MPEG：Motion Picture Experts Group（国际标准组织机构）</li>
</ul>
</li>
<li>H.26X系列（由ITU[国际电传视讯联盟]主导）<ul>
<li>  H.261：主要在老的视频会议和视频电话产品中使用</li>
<li>  H.263：主要用在视频会议、视频电话和网络视频上</li>
<li>  H.264：H.264/MPEG-4第十部分，或称AVC（Advanced Video Coding，高级视频编码），是一种视频压缩标准，一种被广泛使用的高精度视频的录制、压缩和发布格式。</li>
<li>  H.265：高效率视频编码（High Efficiency Video Coding，简称HEVC）是一种视频压缩标准，H.264/MPEG-4 AVC的继任者。可支持4K分辨率甚至到超高画质电视，最高分辨率可达到8192×4320（8K分辨率），这是目前发展的趋势，尚未有大众化编码软件出现</li>
</ul>
</li>
<li>MPEG系列（由ISO[国际标准组织机构]下属的MPEG[运动图象专家组]开发）<ul>
<li>  MPEG-1第二部分：MPEG-1第二部分主要使用在VCD上，有些在线视频也使用这种格式</li>
<li>  MPEG-2第二部分（MPEG-2第二部分等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统中</li>
<li>  MPEG-4第二部分（MPEG-4第二部分标准可以使用在网络传输、广播和媒体存储上。 *</li>
</ul>
</li>
<li>其他系列：<ul>
<li>  AMV · AVS · Bink · RealVideo · Theora · VC-1 · VP3 · VP6 · VP7 · VP8 · VP9 · WMV</li>
</ul>
</li>
</ul>
<h3 id="编码的常见流程"><a href="#编码的常见流程" class="headerlink" title="编码的常见流程"></a>编码的常见流程</h3><ul>
<li>  在进行当前信号编码时，编码器首先会产生对当前信号做预测的信号，称作预测信号（predicted signal）</li>
<li>预测的方式：<ul>
<li>  时间上的预测（interprediction），亦即使用先前帧的信号做预测</li>
<li>  空间上的预测 （intra prediction），亦即使用同一张帧之中相邻像素的信号做预测</li>
</ul>
</li>
<li>得到预测信号后，编码器会将当前信号与预测信号相减得到残余信号（residual signal），并只对残余信号进行编码<ul>
<li>  如此一来，可以去除一部份时间上或是空间上的冗余信息</li>
</ul>
</li>
<li>  编码器并不会直接对残余信号进行编码，而是先将残余信号经过变换（通常为离散余弦变换）然后量化以进一步去除空间上和感知上的冗余信息</li>
<li>  量化后得到的量化系数会再透过熵编码，去除统计上的冗余信息</li>
</ul>
<h3 id="目前应用最广泛的H-264（AVC）"><a href="#目前应用最广泛的H-264（AVC）" class="headerlink" title="目前应用最广泛的H.264（AVC）"></a>目前应用最广泛的H.264（AVC）</h3><ul>
<li><p>  H264是新一代的编码标准，以高压缩高质量和支持多种网络的流媒体传输著称</p>
</li>
<li><p>个人理解：</p>
<ul>
<li>  在相邻几幅图像画面中，一般有差别的像素只有10%以内的点,亮度差值变化不超过2%，而色度差值的变化只有1%以内</li>
<li>  所以对于一段变化不大图像画面，我们可以先编码出一个完整的图像帧A，随后的B帧就不编码全部图像，只写入与A帧的差别，这样B帧的大小就只有完整帧的1/10或更小！</li>
<li>  B帧之后的C帧如果变化不大，我们可以继续以参考B的方式编码C帧，这样循环下去。</li>
<li>  这段图像我们称为一个序列：序列就是有相同特点的一段数据</li>
<li>  当某个图像与之前的图像变化很大，无法参考前面的帧来生成，那我们就结束上一个序列，开始下一段序列</li>
<li>  也就是对这个图像生成一个完整帧A1，随后的图像就参考A1生成，只写入与A1的差别内容。</li>
</ul>
</li>
<li><p>在H264协议里定义了三种帧</p>
<ul>
<li>  I帧：完整编码的帧叫I帧</li>
<li>  P帧：参考之前的I帧生成的只包含差异部分编码的帧叫P帧</li>
<li>  B帧：参考前后的帧编码的帧叫B帧</li>
</ul>
</li>
<li><p>H264采用的核心算法是帧内压缩和帧间压缩</p>
<ul>
<li>  帧内压缩是生成I帧的算法</li>
<li>  帧间压缩是生成B帧和P帧的算法</li>
</ul>
</li>
<li><p>H264的压缩方法:</p>
<ul>
<li>  分组:把几帧图像分为一组(GOP，也就是一个序列),为防止运动变化,帧数不宜取多</li>
<li>  定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧;</li>
<li>  预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧;</li>
<li>  数据传输:最后将I帧数据与预测的差值信息进行存储和传输。</li>
</ul>
</li>
<li><p>序列(GOP)</p>
<ul>
<li>  在H264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流。</li>
<li>一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。<ul>
<li>  H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。</li>
<li>  这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。</li>
<li>  IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。</li>
</ul>
</li>
<li>一个序列就是一段内容差异不太大的图像编码后生成的一串数据流<ul>
<li>  当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。</li>
<li>  当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。</li>
</ul>
</li>
<li>  在视频编码序列中，GOP即Group of picture（图像组），指两个I帧之间的距离</li>
<li>  I帧、P帧、B帧的预测方向<br><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231507803" alt="img"></li>
<li>  I帧、P帧、B帧实际顺序&amp;编码后顺序<br><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231505186.png" alt="序列2.png"><h3 id="H264分层设计"><a href="#H264分层设计" class="headerlink" title="H264分层设计"></a>H264分层设计</h3></li>
</ul>
</li>
<li><p>分层设计</p>
<ul>
<li>  H264算法在概念上分为两层：视频编码层（VCL：Video Coding Layer）负责高效的视频内容表示，网络提取层（NAL：Network Abstraction Layer）负责以网络所要求的恰当的方式对数据进行打包和传送。</li>
<li>  这样，高效编码和网络友好性分别由VCL和NAL分别完成</li>
<li>  而之前我们学习的编码方式，都是属于VCL层</li>
</ul>
</li>
<li><p>NAL设计目的：</p>
<ul>
<li>  根据不同的网络把数据打包成相应的格式，将VCL产生的比特字符串适配到各种各样的网络和多元环境中。</li>
</ul>
</li>
<li><p>NAL的封装方式：</p>
<ul>
<li>  NAL是将每一帧数据写入到一个NAL单元中，进行传输或存储的</li>
<li>  NALU分为NAL头和NAL体</li>
<li>  NALU头通常为00 00 00 01，作为一个新的NALU的起始标识</li>
<li>  NALU体封装着VCL编码后的信息或者其他信息</li>
</ul>
</li>
<li><p>封装过程：</p>
<ul>
<li>  I帧、P帧、B帧都是被封装成一个或者多个NALU进行传输或者存储的</li>
<li>  I帧开始之前也有非VCL的NAL单元，用于保存其他信息，比如：PPS、SPS</li>
<li>  PPS（Picture Parameter Sets）：图像参数集</li>
<li>  SPS（Sequence Parameter Set）：序列参数集</li>
<li>  在实际的H264数据帧中，往往帧前面带有00 00 00 01 或 00 00 01分隔符，一般来说编码器编出的首帧数据为PPS与SPS，接着为I帧，后续是B帧、P帧等数据</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231505691.png" alt="H264分层设计.png"></p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><ul>
<li>编码的方式有两种：<ul>
<li>  硬编码：使用非CPU进行编码，如显卡GPU、专用的DSP、FPGA、ASIC芯片等</li>
<li>  软编码：使用CPU进行编码，软编码通常使用：ffmpeg+x264</li>
<li>  ffmpeg：是一套开源的、用于对音视频进行编码&amp;解码&amp;转化计算机程序</li>
<li>  x264：x264是一种免费的、开源的、具有更优秀算法的H.264/MPEG-4 AVC视频压缩编码方式</li>
</ul>
</li>
<li>对比：（没有对比就没有伤害）<ul>
<li>  软编码：实现直接、简单，参数调整方便，升级易，但CPU负载重，性能较硬编码低</li>
<li>  性能高，对CPU没有压力，但是对其他硬件要求较高（如GPU等）</li>
</ul>
</li>
<li>iOS中编码方式：<ul>
<li>  在iOS8之前，苹果并没有开放硬编码的接口，所以只能采用ffpeng+x624进行软编码</li>
<li>  在iOS8之后，苹果开放了接口，并且封装了VideoToolBox&amp;AudioToolbox两个框架，分别用于对视频&amp;音频进行硬编码</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2017/09/09/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BE%8E%E9%A2%9C%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/09/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BE%8E%E9%A2%9C%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">iOS直播技术学习笔记-美颜滤镜效果（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-09 22:59:46" itemprop="dateCreated datePublished" datetime="2017-09-09T22:59:46+08:00">2017-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="GPUImage的介绍"><a href="#GPUImage的介绍" class="headerlink" title="GPUImage的介绍"></a>GPUImage的介绍</h3><ul>
<li>  GPUImage 是一个开源的基于GPU的图片或视频的处理框架，其本身内置了多达120多种常见的滤镜效果</li>
<li>  GPUImage是利用GPU，使在图片和视频上应用不同的效果和滤镜变得非常的容易，同时它还拥有出色的性能，并且它的性能要比苹果内置的相关APIs出色</li>
</ul>
<h3 id="高斯模糊-毛玻璃-效果"><a href="#高斯模糊-毛玻璃-效果" class="headerlink" title="高斯模糊(毛玻璃)效果"></a>高斯模糊(毛玻璃)效果</h3><ul>
<li>在iOS总实现毛玻璃效果方式有很多<ul>
<li>  UIToolBar本身有毛玻璃效果</li>
<li>  iOS8之后UIVisualEffectView直接创建毛玻璃View</li>
<li>  系统CoreImage框架中直接修改图片</li>
<li>  GPUImage框架给图片添加一层滤镜</li>
</ul>
</li>
<li>实现思路<ul>
<li>  获取要修改成毛玻璃的图片</li>
<li>  给图片添加滤镜</li>
<li>  生成新的图片</li>
</ul>
</li>
<li>  实现代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func generateBlurImage(_ sourceImage : UIImage) -&gt; UIImage &#123;</span><br><span class="line">    // 1.创建用于处理单张图片(类似于美图秀秀中打开相册中的图片进行处理)</span><br><span class="line">    let processView = GPUImagePicture(image: sourceImage)</span><br><span class="line"></span><br><span class="line">    // 2.创建滤镜</span><br><span class="line">    let blurFilter = GPUImageGaussianBlurFilter()</span><br><span class="line">    // 纹理大小</span><br><span class="line">    blurFilter.texelSpacingMultiplier = 2.0</span><br><span class="line">    blurFilter.blurRadiusInPixels = 5.0</span><br><span class="line">    processView?.addTarget(blurFilter)</span><br><span class="line"></span><br><span class="line">    // 3.处理图像</span><br><span class="line">    blurFilter.useNextFrameForImageCapture()</span><br><span class="line">    processView?.processImage()</span><br><span class="line"></span><br><span class="line">    // 4.获取最新的图像</span><br><span class="line">    return blurFilter.imageFromCurrentFramebuffer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="其他滤镜效果"><a href="#其他滤镜效果" class="headerlink" title="其他滤镜效果"></a>其他滤镜效果</h3><h4 id="为多个target添加依赖库"><a href="#为多个target添加依赖库" class="headerlink" title="为多个target添加依赖库"></a>为多个target添加依赖库</h4><ul>
<li>  单个target</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#x27;8.0&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line">target &#x27;targetName&#x27; do</span><br><span class="line">    pod &#x27;GPUImage&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  多个target依赖相同的库(Ruby语法)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#x27;9.0&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">targetsArray = [&#x27;01-GPUImage毛玻璃&#x27;, &#x27;02-GPUImage其他滤镜&#x27;]</span><br><span class="line"></span><br><span class="line">targetsArray.each do |t|</span><br><span class="line">    target t do</span><br><span class="line">        pod &#x27;GPUImage&#x27;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  不同target依赖不同的库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#x27;8.0&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line">target &#x27;targetName1&#x27; do</span><br><span class="line">    pod &#x27;Alamofire&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;targetName2&#x27; do</span><br><span class="line">    pod &#x27;Alamofire&#x27;</span><br><span class="line">    pod &#x27;Kingfisher&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul>
<li>  常见滤镜</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 调整颜色 Handle Color</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageBrightnessFilter.h&quot;                //亮度</span><br><span class="line">    #import &quot;GPUImageExposureFilter.h&quot;                  //曝光</span><br><span class="line">    #import &quot;GPUImageContrastFilter.h&quot;                  //对比度</span><br><span class="line">    #import &quot;GPUImageSaturationFilter.h&quot;                //饱和度</span><br><span class="line">    #import &quot;GPUImageGammaFilter.h&quot;                     //伽马线</span><br><span class="line">    #import &quot;GPUImageColorInvertFilter.h&quot;               //反色</span><br><span class="line">    #import &quot;GPUImageSepiaFilter.h&quot;                     //褐色（怀旧）</span><br><span class="line">    #import &quot;GPUImageLevelsFilter.h&quot;                    //色阶</span><br><span class="line">    #import &quot;GPUImageGrayscaleFilter.h&quot;                 //灰度</span><br><span class="line">    #import &quot;GPUImageHistogramFilter.h&quot;                 //色彩直方图，显示在图片上</span><br><span class="line">    #import &quot;GPUImageHistogramGenerator.h&quot;              //色彩直方图</span><br><span class="line">    #import &quot;GPUImageRGBFilter.h&quot;                       //RGB</span><br><span class="line">    #import &quot;GPUImageToneCurveFilter.h&quot;                 //色调曲线</span><br><span class="line">    #import &quot;GPUImageMonochromeFilter.h&quot;                //单色</span><br><span class="line">    #import &quot;GPUImageOpacityFilter.h&quot;                   //不透明度</span><br><span class="line">    #import &quot;GPUImageHighlightShadowFilter.h&quot;           //提亮阴影</span><br><span class="line">    #import &quot;GPUImageFalseColorFilter.h&quot;                //色彩替换（替换亮部和暗部色彩）</span><br><span class="line">    #import &quot;GPUImageHueFilter.h&quot;                       //色度</span><br><span class="line">    #import &quot;GPUImageChromaKeyFilter.h&quot;                 //色度键</span><br><span class="line">    #import &quot;GPUImageWhiteBalanceFilter.h&quot;              //白平横</span><br><span class="line">    #import &quot;GPUImageAverageColor.h&quot;                    //像素平均色值</span><br><span class="line">    #import &quot;GPUImageSolidColorGenerator.h&quot;             //纯色</span><br><span class="line">    #import &quot;GPUImageLuminosity.h&quot;                      //亮度平均</span><br><span class="line">    #import &quot;GPUImageAverageLuminanceThresholdFilter.h&quot; //像素色值亮度平均，图像黑白（有类似漫画效果）</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageLookupFilter.h&quot;                    //lookup 色彩调整</span><br><span class="line">    #import &quot;GPUImageAmatorkaFilter.h&quot;                  //Amatorka lookup</span><br><span class="line">    #import &quot;GPUImageMissEtikateFilter.h&quot;               //MissEtikate lookup</span><br><span class="line">    #import &quot;GPUImageSoftEleganceFilter.h&quot;              //SoftElegance lookup</span><br><span class="line"></span><br><span class="line">    #pragma mark - 图像处理 Handle Image</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageCrosshairGenerator.h&quot;              //十字</span><br><span class="line">    #import &quot;GPUImageLineGenerator.h&quot;                   //线条</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageTransformFilter.h&quot;                 //形状变化</span><br><span class="line">    #import &quot;GPUImageCropFilter.h&quot;                      //剪裁</span><br><span class="line">    #import &quot;GPUImageSharpenFilter.h&quot;                   //锐化</span><br><span class="line">    #import &quot;GPUImageUnsharpMaskFilter.h&quot;               //反遮罩锐化</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageFastBlurFilter.h&quot;                  //模糊</span><br><span class="line">    #import &quot;GPUImageGaussianBlurFilter.h&quot;              //高斯模糊</span><br><span class="line">    #import &quot;GPUImageGaussianSelectiveBlurFilter.h&quot;     //高斯模糊，选择部分清晰</span><br><span class="line">    #import &quot;GPUImageBoxBlurFilter.h&quot;                   //盒状模糊</span><br><span class="line">    #import &quot;GPUImageTiltShiftFilter.h&quot;                 //条纹模糊，中间清晰，上下两端模糊</span><br><span class="line">    #import &quot;GPUImageMedianFilter.h&quot;                    //中间值，有种稍微模糊边缘的效果</span><br><span class="line">    #import &quot;GPUImageBilateralFilter.h&quot;                 //双边模糊</span><br><span class="line">    #import &quot;GPUImageErosionFilter.h&quot;                   //侵蚀边缘模糊，变黑白</span><br><span class="line">    #import &quot;GPUImageRGBErosionFilter.h&quot;                //RGB侵蚀边缘模糊，有色彩</span><br><span class="line">    #import &quot;GPUImageDilationFilter.h&quot;                  //扩展边缘模糊，变黑白</span><br><span class="line">    #import &quot;GPUImageRGBDilationFilter.h&quot;               //RGB扩展边缘模糊，有色彩</span><br><span class="line">    #import &quot;GPUImageOpeningFilter.h&quot;                   //黑白色调模糊</span><br><span class="line">    #import &quot;GPUImageRGBOpeningFilter.h&quot;                //彩色模糊</span><br><span class="line">    #import &quot;GPUImageClosingFilter.h&quot;                   //黑白色调模糊，暗色会被提亮</span><br><span class="line">    #import &quot;GPUImageRGBClosingFilter.h&quot;                //彩色模糊，暗色会被提亮</span><br><span class="line">    #import &quot;GPUImageLanczosResamplingFilter.h&quot;         //Lanczos重取样，模糊效果</span><br><span class="line">    #import &quot;GPUImageNonMaximumSuppressionFilter.h&quot;     //非最大抑制，只显示亮度最高的像素，其他为黑</span><br><span class="line">    #import &quot;GPUImageThresholdedNonMaximumSuppressionFilter.h&quot; //与上相比，像素丢失更多</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageSobelEdgeDetectionFilter.h&quot;        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)</span><br><span class="line">    #import &quot;GPUImageCannyEdgeDetectionFilter.h&quot;        //Canny边缘检测算法（比上更强烈的黑白对比度）</span><br><span class="line">    #import &quot;GPUImageThresholdEdgeDetectionFilter.h&quot;    //阈值边缘检测（效果与上差别不大）</span><br><span class="line">    #import &quot;GPUImagePrewittEdgeDetectionFilter.h&quot;      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)</span><br><span class="line">    #import &quot;GPUImageXYDerivativeFilter.h&quot;              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色</span><br><span class="line">    #import &quot;GPUImageHarrisCornerDetectionFilter.h&quot;     //Harris角点检测，会有绿色小十字显示在图片角点处</span><br><span class="line">    #import &quot;GPUImageNobleCornerDetectionFilter.h&quot;      //Noble角点检测，检测点更多</span><br><span class="line">    #import &quot;GPUImageShiTomasiFeatureDetectionFilter.h&quot; //ShiTomasi角点检测，与上差别不大</span><br><span class="line">    #import &quot;GPUImageMotionDetector.h&quot;                  //动作检测</span><br><span class="line">    #import &quot;GPUImageHoughTransformLineDetector.h&quot;      //线条检测</span><br><span class="line">    #import &quot;GPUImageParallelCoordinateLineTransformFilter.h&quot; //平行线检测</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageLocalBinaryPatternFilter.h&quot;        //图像黑白化，并有大量噪点</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageLowPassFilter.h&quot;                   //用于图像加亮</span><br><span class="line">    #import &quot;GPUImageHighPassFilter.h&quot;                  //图像低于某值时显示为黑</span><br><span class="line"></span><br><span class="line">    #pragma mark - 视觉效果 Visual Effect</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageSketchFilter.h&quot;                    //素描</span><br><span class="line">    #import &quot;GPUImageThresholdSketchFilter.h&quot;           //阀值素描，形成有噪点的素描</span><br><span class="line">    #import &quot;GPUImageToonFilter.h&quot;                      //卡通效果（黑色粗线描边）</span><br><span class="line">    #import &quot;GPUImageSmoothToonFilter.h&quot;                //相比上面的效果更细腻，上面是粗旷的画风</span><br><span class="line">    #import &quot;GPUImageKuwaharaFilter.h&quot;                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageMosaicFilter.h&quot;                    //黑白马赛克</span><br><span class="line">    #import &quot;GPUImagePixellateFilter.h&quot;                 //像素化</span><br><span class="line">    #import &quot;GPUImagePolarPixellateFilter.h&quot;            //同心圆像素化</span><br><span class="line">    #import &quot;GPUImageCrosshatchFilter.h&quot;                //交叉线阴影，形成黑白网状画面</span><br><span class="line">    #import &quot;GPUImageColorPackingFilter.h&quot;              //色彩丢失，模糊（类似监控摄像效果）</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageVignetteFilter.h&quot;                  //晕影，形成黑色圆形边缘，突出中间图像的效果</span><br><span class="line">    #import &quot;GPUImageSwirlFilter.h&quot;                     //漩涡，中间形成卷曲的画面</span><br><span class="line">    #import &quot;GPUImageBulgeDistortionFilter.h&quot;           //凸起失真，鱼眼效果</span><br><span class="line">    #import &quot;GPUImagePinchDistortionFilter.h&quot;           //收缩失真，凹面镜</span><br><span class="line">    #import &quot;GPUImageStretchDistortionFilter.h&quot;         //伸展失真，哈哈镜</span><br><span class="line">    #import &quot;GPUImageGlassSphereFilter.h&quot;               //水晶球效果</span><br><span class="line">    #import &quot;GPUImageSphereRefractionFilter.h&quot;          //球形折射，图形倒立</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImagePosterizeFilter.h&quot;                 //色调分离，形成噪点效果</span><br><span class="line">    #import &quot;GPUImageCGAColorspaceFilter.h&quot;             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面</span><br><span class="line">    #import &quot;GPUImagePerlinNoiseFilter.h&quot;               //柏林噪点，花边噪点</span><br><span class="line">    #import &quot;GPUImage3x3ConvolutionFilter.h&quot;            //3x3卷积，高亮大色块变黑，加亮边缘、线条等</span><br><span class="line">    #import &quot;GPUImageEmbossFilter.h&quot;                    //浮雕效果，带有点3d的感觉</span><br><span class="line">    #import &quot;GPUImagePolkaDotFilter.h&quot;                  //像素圆点花样</span><br><span class="line">    #import &quot;GPUImageHalftoneFilter.h&quot;                  //点染,图像黑白化，由黑点构成原图的大致图形</span><br><span class="line"></span><br><span class="line">    #pragma mark - 混合模式 Blend</span><br><span class="line"></span><br><span class="line">    #import &quot;GPUImageMultiplyBlendFilter.h&quot;             //通常用于创建阴影和深度效果</span><br><span class="line">    #import &quot;GPUImageNormalBlendFilter.h&quot;               //正常</span><br><span class="line">    #import &quot;GPUImageAlphaBlendFilter.h&quot;                //透明混合,通常用于在背景上应用前景的透明度</span><br><span class="line">    #import &quot;GPUImageDissolveBlendFilter.h&quot;             //溶解</span><br><span class="line">    #import &quot;GPUImageOverlayBlendFilter.h&quot;              //叠加,通常用于创建阴影效果</span><br><span class="line">    #import &quot;GPUImageDarkenBlendFilter.h&quot;               //加深混合,通常用于重叠类型</span><br><span class="line">    #import &quot;GPUImageLightenBlendFilter.h&quot;              //减淡混合,通常用于重叠类型</span><br><span class="line">    #import &quot;GPUImageSourceOverBlendFilter.h&quot;           //源混合</span><br><span class="line">    #import &quot;GPUImageColorBurnBlendFilter.h&quot;            //色彩加深混合</span><br><span class="line">    #import &quot;GPUImageColorDodgeBlendFilter.h&quot;           //色彩减淡混合</span><br><span class="line">    #import &quot;GPUImageScreenBlendFilter.h&quot;               //屏幕包裹,通常用于创建亮点和镜头眩光</span><br><span class="line">    #import &quot;GPUImageExclusionBlendFilter.h&quot;            //排除混合</span><br><span class="line">    #import &quot;GPUImageDifferenceBlendFilter.h&quot;           //差异混合,通常用于创建更多变动的颜色</span><br><span class="line">    #import &quot;GPUImageSubtractBlendFilter.h&quot;             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果</span><br><span class="line">    #import &quot;GPUImageHardLightBlendFilter.h&quot;            //强光混合,通常用于创建阴影效果</span><br><span class="line">    #import &quot;GPUImageSoftLightBlendFilter.h&quot;            //柔光混合</span><br><span class="line">    #import &quot;GPUImageChromaKeyBlendFilter.h&quot;            //色度键混合</span><br><span class="line">    #import &quot;GPUImageMaskFilter.h&quot;                      //遮罩混合</span><br><span class="line">    #import &quot;GPUImageHazeFilter.h&quot;                      //朦胧加暗</span><br><span class="line">    #import &quot;GPUImageLuminanceThresholdFilter.h&quot;        //亮度阈</span><br><span class="line">    #import &quot;GPUImageAdaptiveThresholdFilter.h&quot;         //自适应阈值</span><br><span class="line">    #import &quot;GPUImageAddBlendFilter.h&quot;                  //通常用于创建两个图像之间的动画变亮模糊效果</span><br><span class="line">    #import &quot;GPUImageDivideBlendFilter.h&quot;               //通常用于创建两个图像之间的动画变暗模糊效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="GPUImage美颜相机"><a href="#GPUImage美颜相机" class="headerlink" title="GPUImage美颜相机"></a>GPUImage美颜相机</h3><ul>
<li>  GPUImageStillCamera用于拍摄当前手机的画面, 但是通常不会用实时视频的录制(使用另外一个), 主要用户拍摄某一个画面, 并且保存(显示)图片</li>
<li>  GPUImageStillCamera-&gt;GPUImageFilter-&gt;GPUImageView 这样,摄像机转到滤镜再转到view上显示出来.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//可以理解为设备</span><br><span class="line">GPUImageStillCamera* imageCamera;</span><br><span class="line">//filter滤镜</span><br><span class="line">GPUImageFilter* filter;</span><br><span class="line">//显示出来的view</span><br><span class="line">GPUImageView* iv;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  sessionPreset参数设置</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231504093" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231504310" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet var imageView : UIImageView!</span><br><span class="line">    fileprivate var stillCamera : GPUImageStillCamera?</span><br><span class="line">    fileprivate var filter : GPUImageBrightnessFilter!</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        // 1.创建相机</span><br><span class="line">        stillCamera = GPUImageStillCamera(sessionPreset: AVCaptureSessionPreset640x480, cameraPosition: .front)</span><br><span class="line">        stillCamera?.outputImageOrientation = .portrait</span><br><span class="line"></span><br><span class="line">        // 2.创建滤镜</span><br><span class="line">        filter = GPUImageBrightnessFilter()</span><br><span class="line">        filter.brightness = 0.3</span><br><span class="line">        stillCamera?.addTarget(filter)</span><br><span class="line"></span><br><span class="line">        // 3.创建显示实时画面的View</span><br><span class="line">        let showView = GPUImageView(frame: view.bounds)</span><br><span class="line">        view.insertSubview(showView, at: 0)</span><br><span class="line">        filter.addTarget(showView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @IBAction func rotateCamera() &#123;</span><br><span class="line">        stillCamera?.startCapture()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @IBAction func start() &#123;</span><br><span class="line">        stillCamera?.rotateCamera()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @IBAction func stop() &#123;</span><br><span class="line">        stillCamera?.capturePhotoAsImageProcessedUp(toFilter: filter, withCompletionHandler: &#123; (image :  UIImage?, error : Error?) in</span><br><span class="line">            UIImageWriteToSavedPhotosAlbum(image!, nil, nil, nil)</span><br><span class="line">            self.stillCamera?.stopCapture()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2017/09/08/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%87%87%E9%9B%86%E8%A7%86%E9%A2%91%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/08/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%87%87%E9%9B%86%E8%A7%86%E9%A2%91%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">iOS直播技术学习笔记-采集视频（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-08 22:00:56" itemprop="dateCreated datePublished" datetime="2017-09-08T22:00:56+08:00">2017-09-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>音视频采集是直播架构的第一环，是视频的来源</p>
<ul>
<li>其实视频的采集有多个应用场景：比如二维码开发</li>
</ul>
</li>
<li><p>音视频采集包括两部分：</p>
<ul>
<li>视频采集</li>
<li>音频采集</li>
</ul>
</li>
<li><p>在iOS开发中，是可以同步采集视频&amp;音频的，使用方式也非常简单</p>
</li>
<li><p>相关的采集API都封装在AVFoundation框架中，导入对应框架，实现功能即可</p>
</li>
</ul>
<h4 id="采集步骤"><a href="#采集步骤" class="headerlink" title="采集步骤"></a>采集步骤</h4><h5 id="采集步骤文字描述"><a href="#采集步骤文字描述" class="headerlink" title="采集步骤文字描述"></a>采集步骤文字描述</h5><ul>
<li><p>PS：如果做过二维码开发，应该对相关步骤非常熟悉（非常类似）</p>
</li>
<li><p>导入框架</p>
<ul>
<li>相关API主要在AVFoundation框架中，因此需要先导入框架</li>
</ul>
</li>
<li><p>创建捕捉会话（AVCaptureSession）</p>
<ul>
<li>该会话用于连接之后的输入源&amp;输出源</li>
<li>输入源：摄像头&amp;话筒</li>
<li>输出源：拿到对应的音频&amp;视频数据的出口</li>
<li>会话：用于将输入源&amp;输出源连接起来</li>
</ul>
</li>
<li><p>设置视频输入源&amp;输出源</p>
<ul>
<li>输入源（AVCaptureDeviceInput）：从摄像头输入</li>
<li>输出源（AVCaptureVideoDataOutput）：可以设置代理，在代理方法中拿到数据</li>
<li>将输入&amp;输出添加到会话中</li>
</ul>
</li>
<li><p>设置音频输入源&amp;输出源</p>
<ul>
<li>输入源（AVCaptureDeviceInput）：从话筒输入</li>
<li>输出源（AVCaptureAudioDataOutput）：可以设置代理，在代理方法中拿到数据</li>
<li>将输入&amp;输出添加到会话中</li>
</ul>
</li>
<li><p>添加预览图层（可选）</p>
<ul>
<li>如果希望用户看到采集的画面，可以添加预览图层</li>
<li>该预览图层不是必须的，及时没有添加也可以正常采集数据</li>
</ul>
</li>
<li><p>开始采集即可</p>
<ul>
<li> 调用会话（AVCaptureSession）的startRunning方法即可开始采集</li>
</ul>
</li>
</ul>
<h5 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h5><ul>
<li>整体代码步骤</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231450614" alt="整体代码步骤"></p>
<ul>
<li>函数一（设置视频输入输出）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231451857" alt="设置视频输入输出"></p>
<ul>
<li>函数二（设置音频输入输出）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231451037" alt="设置音频输入输出"></p>
<ul>
<li>添加预览图层</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231452344" alt="添加预览图层"></p>
<ul>
<li>遵守协议，实现代理方法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231452485" alt="遵守协议，实现代理方法"></p>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><ul>
<li>整体步骤代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建捕捉会话</span><br><span class="line">let session = AVCaptureSession()</span><br><span class="line"></span><br><span class="line">// 2.设置视频输入输出</span><br><span class="line">setupVideoSource(session: session)</span><br><span class="line"></span><br><span class="line">// 3.设置音频输入输出</span><br><span class="line">setupAudioSource(session: session)</span><br><span class="line"></span><br><span class="line">// 4.添加预览图层</span><br><span class="line">setupPreviewLayer(session: session)</span><br><span class="line"></span><br><span class="line">// 5.开始扫描</span><br><span class="line">session.startRunning()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数一（设置视频输入输出）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 给会话设置视频源（输入源&amp;输出源）</span><br><span class="line">fileprivate func setupVideoSource(session : AVCaptureSession) &#123;</span><br><span class="line">    // 1.创建输入</span><br><span class="line">    // 1.1.获取所有的设备（包括前置&amp;后置摄像头）</span><br><span class="line">    guard let devices = AVCaptureDevice.devices(withMediaType: AVMediaTypeVideo) as? [AVCaptureDevice] else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">    // 1.2.取出获取前置摄像头</span><br><span class="line">    let d = devices.filter(&#123; return $0.position == .front &#125;).first</span><br><span class="line"></span><br><span class="line">    // 1.3.通过前置摄像头创建输入设备</span><br><span class="line">    guard let videoInput = try? AVCaptureDeviceInput(device: d) else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">    // 2.创建输出源</span><br><span class="line">    // 2.1.创建视频输出源</span><br><span class="line">    let videoOutput = AVCaptureVideoDataOutput()</span><br><span class="line"></span><br><span class="line">    // 2.2.设置代理,以及代理方法的执行队列（在代理方法中拿到采集到的数据）</span><br><span class="line">    let queue = DispatchQueue.global()</span><br><span class="line">    videoOutput.setSampleBufferDelegate(self, queue: queue)</span><br><span class="line"></span><br><span class="line">    // 3.将输入&amp;输出添加到会话中</span><br><span class="line">    // 3.1.添加输入源</span><br><span class="line">    if session.canAddInput(videoInput) &#123;</span><br><span class="line">        session.addInput(videoInput)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.2.添加输出源</span><br><span class="line">    if session.canAddOutput(videoOutput) &#123;</span><br><span class="line">        session.addOutput(videoOutput)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4.给connect赋值</span><br><span class="line">    videoConnect = videoOutput.connection(withMediaType: AVMediaTypeVideo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数二（设置音频输入输出）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 给会话设置音频源（输入源&amp;输出源）</span><br><span class="line">fileprivate func setupAudioSource(session : AVCaptureSession) &#123;</span><br><span class="line">    // 1.创建输入</span><br><span class="line">    guard let device = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeAudio) else &#123; return &#125;</span><br><span class="line">    guard let audioInput = try? AVCaptureDeviceInput(device: device) else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">    // 2.创建输出源</span><br><span class="line">    let audioOutput = AVCaptureAudioDataOutput()</span><br><span class="line">    let queue = DispatchQueue.global()</span><br><span class="line">    audioOutput.setSampleBufferDelegate(self, queue: queue)</span><br><span class="line"></span><br><span class="line">    // 3.将输入&amp;输出添加到会话中</span><br><span class="line">    if session.canAddInput(audioInput) &#123;</span><br><span class="line">        session.addInput(audioInput)</span><br><span class="line">    &#125;</span><br><span class="line">    if session.canAddOutput(audioOutput) &#123;</span><br><span class="line">        session.addOutput(audioOutput)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>添加预览图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 添加预览图层 </span><br><span class="line">    // 添加预览图层</span><br><span class="line">    fileprivate func setupPreviewLayer(session : AVCaptureSession) &#123;</span><br><span class="line">        // 1.创建预览图层</span><br><span class="line">        guard let previewLayer = AVCaptureVideoPreviewLayer(session: session) else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">        // 2.设置图层的属性</span><br><span class="line">        previewLayer.frame = view.bounds</span><br><span class="line"></span><br><span class="line">        // 3.将图层添加到view中</span><br><span class="line">        view.layer.insertSublayer(previewLayer, at: 0)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遵守协议，实现代理方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController : AVCaptureVideoDataOutputSampleBufferDelegate, AVCaptureAudioDataOutputSampleBufferDelegate &#123;</span><br><span class="line">    func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputSampleBuffer sampleBuffer: CMSampleBuffer!, from connection: AVCaptureConnection!) &#123;</span><br><span class="line">        if connection == videoConnect &#123;</span><br><span class="line">            print(&quot;视频数据&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            print(&quot;音频数据&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="停止扫描"><a href="#停止扫描" class="headerlink" title="停止扫描"></a>停止扫描</h5></li>
<li><p>比如用户不再直接，我们需要停止扫描</p>
<ul>
<li>移除预览图层（不再直播肯定不需要预览图层了）</li>
<li>停止扫描（调用session的stopRunning方法）</li>
<li>将session设置为nil（对象不再使用，指针置空）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func stopScanning() &#123;</span><br><span class="line">       // 1.移除图层</span><br><span class="line">       previewLayer?.removeFromSuperlayer()</span><br><span class="line"></span><br><span class="line">       // 2.停止扫描</span><br><span class="line">       session?.stopRunning()</span><br><span class="line"></span><br><span class="line">       // 3.将对象重置为nil</span><br><span class="line">       session = nil</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="切换镜头-amp-聚焦-amp-写入文件"><a href="#切换镜头-amp-聚焦-amp-写入文件" class="headerlink" title="切换镜头&amp;聚焦&amp;写入文件"></a>切换镜头&amp;聚焦&amp;写入文件</h4><h5 id="切换镜头（前置-amp-后置摄像头）"><a href="#切换镜头（前置-amp-后置摄像头）" class="headerlink" title="切换镜头（前置&amp;后置摄像头）"></a>切换镜头（前置&amp;后置摄像头）</h5><ul>
<li><p>切换步骤</p>
<ul>
<li><p>给切换过程添加动画</p>
</li>
<li><p>获取当前摄像头是前置还是后置</p>
</li>
<li><p>取出相反的摄像头（之前是前置，这次取出后置）</p>
</li>
<li><p>通过新摄像头重新获取设备（AVCaptureDevice）</p>
</li>
<li><p>通过设备（AVCaptureDevice）创建新的输入（AVCaptureDeviceInput）</p>
</li>
<li><p>移除旧input&amp;添加新的input</p>
<ul>
<li>注意：修改session配置之前先调用开启修改配置选项，配置完成后，调用提交修改配置选项</li>
<li>session?.beginConfiguration()</li>
<li>session?.commitConfiguration()</li>
</ul>
</li>
<li><p>保存新的input</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func switchScene() &#123;</span><br><span class="line">      // 0.执行动画</span><br><span class="line">      let rotaionAnim = CATransition()</span><br><span class="line">      rotaionAnim.type = &quot;oglFlip&quot;</span><br><span class="line">      rotaionAnim.subtype = &quot;fromLeft&quot;</span><br><span class="line">      rotaionAnim.duration = 0.5</span><br><span class="line">      view.layer.add(rotaionAnim, forKey: nil)</span><br><span class="line"></span><br><span class="line">      // 1.校验videoInput是否有值</span><br><span class="line">      guard let videoInput = videoInput else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">      // 2.获取当前镜头</span><br><span class="line">      let position : AVCaptureDevicePosition = videoInput.device.position == .front ? .back : .front</span><br><span class="line"></span><br><span class="line">      // 3.创建新的input</span><br><span class="line">      guard let devices = AVCaptureDevice.devices(withMediaType: AVMediaTypeVideo) as? [AVCaptureDevice] else &#123; return &#125;</span><br><span class="line">      guard let newDevice = devices.filter(&#123;$0.position == position&#125;).first else &#123; return &#125;</span><br><span class="line">      guard let newVideoInput = try? AVCaptureDeviceInput(device: newDevice) else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">      // 4.移除旧输入，添加新输入</span><br><span class="line">      session?.beginConfiguration()</span><br><span class="line">      session?.removeInput(videoInput)</span><br><span class="line">      session?.addInput(newVideoInput)</span><br><span class="line">      session?.commitConfiguration()</span><br><span class="line"></span><br><span class="line">      // 5.保存新输入</span><br><span class="line">      self.videoInput = newVideoInput</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h5><ul>
<li><p>写入文件步骤</p>
<ul>
<li><p>创建AVCaptureMovieFileOutput对象</p>
<ul>
<li>用于将音频视频写入文件</li>
</ul>
</li>
<li><p>将movieFileOutput对象，添加到session的输出中</p>
<ul>
<li>写入文件也是一种输出</li>
</ul>
</li>
<li><p>设置视频的稳定模式</p>
<ul>
<li>不设置可能会出现视频跳帧等问题</li>
<li>通常设置为自动即可</li>
</ul>
</li>
<li><p>开始写入</p>
</li>
<li><p>录制完成，停止写入即可</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>代码如下：</p>
</li>
<li><p>创建、添加、设置代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 添加文件输出</span><br><span class="line">   let movieFileoutput = AVCaptureMovieFileOutput()</span><br><span class="line">   self.movieFileOutput = movieFileoutput</span><br><span class="line">   session.addOutput(movieFileoutput)</span><br><span class="line">   // 获取视频的connection</span><br><span class="line">   let connection = movieFileoutput.connection(withMediaType: AVMediaTypeVideo)</span><br><span class="line">   // 设置视频的稳定模式</span><br><span class="line">   connection?.preferredVideoStabilizationMode = .auto</span><br><span class="line"></span><br><span class="line">   // 开始写入视频</span><br><span class="line">   movieFileoutput.startRecording(toOutputFileURL: outputFileURL, recordingDelegate: self)</span><br></pre></td></tr></table></figure></li>
<li><p>停止写入代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 0.停止写入</span><br><span class="line">self.movieFileOutput?.stopRecording()</span><br></pre></td></tr></table></figure></li>
<li><p>在代理方法中监听开始、结束事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController : AVCaptureFileOutputRecordingDelegate &#123;</span><br><span class="line">    func capture(_ captureOutput: AVCaptureFileOutput!, didStartRecordingToOutputFileAt fileURL: URL!, fromConnections connections: [Any]!) &#123;</span><br><span class="line">        print(&quot;开始录制&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func capture(_ captureOutput: AVCaptureFileOutput!, didFinishRecordingToOutputFileAt outputFileURL: URL!, fromConnections connections: [Any]!, error: Error!) &#123;</span><br><span class="line">        print(&quot;停止录制&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2017/09/06/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9B%B4%E6%92%AD%E6%80%BB%E4%BD%93%E6%A6%82%E8%A7%88%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/06/iOS%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9B%B4%E6%92%AD%E6%80%BB%E4%BD%93%E6%A6%82%E8%A7%88%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">iOS直播技术学习笔记-直播总体概览（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-09-06 21:01:11" itemprop="dateCreated datePublished" datetime="2017-09-06T21:01:11+08:00">2017-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>直播的现状</p>
<ul>
<li>2016年，是一个直播年。直播行业快速发展，同时也滋生了大大小小上千家相关的公司。</li>
<li>中国互联网络信息中心发布的报告显示，截至今年6月，我国网络直播用户规模达到3.25亿，占网民总体的45.8%。</li>
</ul>
</li>
<li><p>直播的技术</p>
<ul>
<li><p>直播技术概况来说，可以分为 采集，前处理，编码，传输，解码，渲染 这几个环节</p>
<h4 id="技术整体概览"><a href="#技术整体概览" class="headerlink" title="技术整体概览"></a>技术整体概览</h4></li>
</ul>
</li>
<li><p>图例：<br><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231446819.png" alt="技术整体总结.png"></p>
</li>
</ul>
<h4 id="分步解析"><a href="#分步解析" class="headerlink" title="分步解析"></a>分步解析</h4><h5 id="音视频采集"><a href="#音视频采集" class="headerlink" title="音视频采集"></a>音视频采集</h5><ul>
<li><p>音视频的采集是直播架构的第一个环节，也是直播的视频来源</p>
</li>
<li><p>采集的来源包括：</p>
<ul>
<li><p>PC端：屏幕摄像头（摄像头驱动适配）</p>
</li>
<li><p>iOS端：摄像头采集（屏幕采集？）</p>
</li>
<li><p>Android端：屏幕摄像头采集（硬件过多，适配一堆坑）</p>
<h5 id="前处理"><a href="#前处理" class="headerlink" title="前处理"></a>前处理</h5></li>
</ul>
</li>
<li><p>使用美颜相机&amp;美图秀秀已经是网络发照片&amp;发视频必备技能了</p>
<ul>
<li>80%的主播没有美颜简直不能看（当然还是有美女的）</li>
<li>不能看如何吸引用户&amp;观众</li>
<li>对视频进行美颜，已成标配</li>
</ul>
</li>
<li><p>处理主要包括，美颜、模糊效果、水印等</p>
<ul>
<li>总之就是让人变美、变帅</li>
</ul>
</li>
<li><p>各个平台处理方式</p>
<ul>
<li><p>PC端：美颜镜头、一些美颜软件</p>
</li>
<li><p>iOS端：图像处理库是GPUImage，提供了丰富的预处理效果，也可利用该库自定义设计</p>
</li>
<li><p>Android端：Google开源的grafika，是一个非常强大的图形处理库</p>
<h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5></li>
</ul>
</li>
<li><p>不经编码的视频非常庞大，存储起来都麻烦，更何况网络传输</p>
<ul>
<li>编码通过压缩音视频数据来减少数据体积，方便音视频数据的推流，拉流和存储，能大大提高存储传输效率</li>
<li>音视频必须经过压缩编码才能进行存储和传输</li>
</ul>
</li>
<li><p>编码方式：</p>
<ul>
<li>硬编码：使用非CPU进行编码，如显卡GPU、专用的DSP芯片等</li>
<li>软编码：使用CPU进行编码（手机容易发热）</li>
</ul>
</li>
<li><p>各个平台处理：</p>
<ul>
<li>iOS端：硬件兼容性较好，可以直接进行硬编码</li>
<li>Android端：硬编码较难，难找到统一的库兼容各个平台（推荐使用软编）</li>
</ul>
</li>
<li><p>编码标准：</p>
<ul>
<li><p>视频编码：H.265、H.264、VP8、VP9等</p>
</li>
<li><p>音频编码：AAC、Opus</p>
<h5 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h5></li>
</ul>
</li>
<li><p>从推流端到服务端</p>
<ul>
<li>数据经过推流端采集和预处理，编码之后推流到服务端</li>
<li>流传输就涉及到相应的传输协议，最常用的协议是RTMP、RTSP、HLS</li>
</ul>
</li>
<li><p>搭建nginx+rtmp服务器进行推流演示</p>
<h5 id="流分发"><a href="#流分发" class="headerlink" title="流分发"></a>流分发</h5></li>
<li><p>音频流推到服务器后，为了适配各个平台端各种不同协议，需要在服务端做一些流处理工作，比如转码成不同格式支持不同协议如 RTMP、HLS 和 FLV，以适应各个平台</p>
<ul>
<li>比如：iOS、Android、PC、网页</li>
</ul>
</li>
<li><p>甚至，为了配合一些运营需求，比如一些监管部门的要求，我们在服务端也提供了内容识别如鉴黄的功能</p>
<h5 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h5></li>
<li><p>拉流获取音视频数据后，需要通过解码器解码，渲染才能在播放器上播放</p>
</li>
<li><p>总体步骤概览：</p>
<ul>
<li>解协议：取出网络传输过程中一些无用信息</li>
<li>解封装：获取到的是音频&amp;视频放在一起的封装文件</li>
<li>音视频解码：音视频都是经过压缩编码的内容，解码后才能进行播放</li>
<li>音视频同步：视频&amp;音频文件需要通过播放</li>
<li>音视频播放：声卡&amp;显卡等对音视频进行播放</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tate-zwt.github.io/2017/08/25/Swift%E5%BC%80%E5%8F%91%E4%B9%8B%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱吃番茄炒蛋">
      <meta itemprop="description" content="「 少点虚的，多点实践 」">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tate Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/25/Swift%E5%BC%80%E5%8F%91%E4%B9%8B%E7%B2%92%E5%AD%90%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Swift开发之粒子动画的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-25 20:41:59" itemprop="dateCreated datePublished" datetime="2017-08-25T20:41:59+08:00">2017-08-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="粒子系统介绍"><a href="#粒子系统介绍" class="headerlink" title="粒子系统介绍"></a>粒子系统介绍</h4><ul>
<li>什么是粒子系统？<ul>
<li>粒子系统是由总体具有相同的表现规律，个体却随机表现出不同的特征的大量显示元素构成的集合。</li>
</ul>
</li>
<li>粒子定义有三要素<ul>
<li>群体性：粒子系统是由“大量显示元素”构成的(例如雪、雨、一团雾等等)</li>
<li>统一性：粒子系统的每个元素具有相同的表现规律(例如下雨、下雪，方向都是从上向下)</li>
<li>随机性：粒子系统的每个元素又随机表现出不同特征(例如下雪，每个雪花下落的速度会有不同，大小会有不同、方向也会有略微的不同)</li>
</ul>
</li>
</ul>
<h4 id="粒子系统应用场景"><a href="#粒子系统应用场景" class="headerlink" title="粒子系统应用场景"></a>粒子系统应用场景</h4><ul>
<li>影视行业<ul>
<li>目前我们经常看的大片，比如沙尘暴、暴风雨、暴雪、烟花 等等，很多都是粒子特效做出来的。很逼真，而且相比真实世界中去实拍，成本要低很多</li>
</ul>
</li>
<li>游戏中<ul>
<li>爆炸、雨、雪、雾、烟花等等。都是粒子系统实现</li>
</ul>
</li>
<li>应用中<ul>
<li>主播房间右下角粒子动画</li>
<li>雪花/下雨/烟花等效果</li>
<li>QQ生日快乐一堆表情的跳动</li>
</ul>
</li>
</ul>
<h4 id="iOS粒子动画的使用"><a href="#iOS粒子动画的使用" class="headerlink" title="iOS粒子动画的使用"></a>iOS粒子动画的使用</h4><ul>
<li>步骤<ul>
<li>创建发射器</li>
<li>创建粒子, 设置粒子属性</li>
</ul>
</li>
<li>swift核心代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建发射器</span><br><span class="line"> let emitter = CAEmitterLayer()</span><br><span class="line"> </span><br><span class="line"> // 2.设置发射器的位置</span><br><span class="line"> emitter.emitterPosition = point</span><br><span class="line"> </span><br><span class="line"> // 3.开启三维效果</span><br><span class="line"> emitter.preservesDepth = true</span><br><span class="line"> </span><br><span class="line"> // 4.创建例子, 并且设置例子相关的属性</span><br><span class="line"> var cells = [CAEmitterCell]()</span><br><span class="line"> for i in 0..&lt;10 &#123;</span><br><span class="line">     // 4.1.创建例子Cell</span><br><span class="line">     let cell = CAEmitterCell()</span><br><span class="line">     </span><br><span class="line">     // 4.2.设置粒子速度</span><br><span class="line">     cell.velocity = 150</span><br><span class="line">     cell.velocityRange = 100</span><br><span class="line">     </span><br><span class="line">     // 4.3.设置例子的大小</span><br><span class="line">     cell.scale = 0.7</span><br><span class="line">     cell.scaleRange = 0.3</span><br><span class="line">     </span><br><span class="line">     // 4.4.设置粒子方向</span><br><span class="line">     cell.emissionLongitude = CGFloat(-Double.pi/2)</span><br><span class="line">     cell.emissionRange = CGFloat(Double.pi/2 / 6)</span><br><span class="line">     </span><br><span class="line">     // 4.5.设置例子的存活时间</span><br><span class="line">     cell.lifetime = 3</span><br><span class="line">     cell.lifetimeRange = 1.5</span><br><span class="line">     </span><br><span class="line">     // 4.6.设置粒子旋转</span><br><span class="line">     cell.spin = CGFloat(Double.pi/2)</span><br><span class="line">     cell.spinRange = CGFloat(Double.pi/2 / 2)</span><br><span class="line">     </span><br><span class="line">     // 4.6.设置例子每秒弹出的个数</span><br><span class="line">     cell.birthRate = 2</span><br><span class="line">     </span><br><span class="line">     // 4.7.设置粒子展示的图片</span><br><span class="line">     cell.contents = UIImage(named: &quot;good\(i)_30x30&quot;)?.cgImage</span><br><span class="line">     </span><br><span class="line">     // 4.8.添加到数组中</span><br><span class="line">     cells.append(cell)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 5.将粒子设置到发射器中</span><br><span class="line"> emitter.emitterCells = cells</span><br><span class="line"> </span><br><span class="line"> // 6.将发射器的layer添加到父layer中</span><br><span class="line"> view.layer.addSublayer(emitter)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="粒子动画效果展示"><a href="#粒子动画效果展示" class="headerlink" title="粒子动画效果展示"></a>粒子动画效果展示</h4><p><img src="https://cdn.jsdelivr.net/gh/Tate-zwt/ImageHost/blog/202112231443242.gif" alt="粒子动画.gif"></p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/Tate-zwt/ParticleAnimationDemo">ParticleAnimationDemo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">爱吃番茄炒蛋</p>
  <div class="site-description" itemprop="description">「 少点虚的，多点实践 」</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tate-zwt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tate-zwt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tate_zhangweiting@163.com" title="E-Mail → mailto:tate_zhangweiting@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">爱吃番茄炒蛋</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
